'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _promise = require('./promise');

var _sanitizePaths = require('./sanitize-paths');

var _sanitizePaths2 = _interopRequireDefault(_sanitizePaths);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const d = require('debug-electron')('electron-compile:file-change-cache');

/**
 * This class caches information about files and determines whether they have
 * changed contents or not. Most importantly, this class caches the hash of seen
 * files so that at development time, we don't have to recalculate them constantly.
 *
 * This class is also the core of how electron-compile runs quickly in production
 * mode - after precompilation, the cache is serialized along with the rest of the
 * data in {@link CompilerHost}, so that when we load the app in production mode,
 * we don't end up calculating hashes of file content at all, only using the contents
 * of this cache.
 */
class FileChangedCache {
  constructor(appRoot) {
    let failOnCacheMiss = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    this.appRoot = (0, _sanitizePaths2.default)(appRoot);

    this.failOnCacheMiss = failOnCacheMiss;
    this.changeCache = {};
  }

  /**
   * Allows you to create a FileChangedCache from serialized data saved from
   * {@link getSavedData}.
   *
   * @param  {Object} data  Saved data from getSavedData.
   *
   * @param  {string} appRoot  The top-level directory for your application (i.e.
   *                           the one which has your package.json).
   *
   * @param  {boolean} failOnCacheMiss (optional)  If True, cache misses will throw.
   *
   * @return {FileChangedCache}
   */
  static loadFromData(data, appRoot) {
    let failOnCacheMiss = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    let ret = new FileChangedCache(appRoot, failOnCacheMiss);
    ret.changeCache = data.changeCache;
    ret.originalAppRoot = data.appRoot;

    return ret;
  }

  /**
   * Allows you to create a FileChangedCache from serialized data saved from
   * {@link save}.
   *
   * @param  {string} file  Saved data from save.
   *
   * @param  {string} appRoot  The top-level directory for your application (i.e.
   *                           the one which has your package.json).
   *
   * @param  {boolean} failOnCacheMiss (optional)  If True, cache misses will throw.
   *
   * @return {Promise<FileChangedCache>}
   */
  static loadFromFile(file, appRoot) {
    let failOnCacheMiss = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    return _asyncToGenerator(function* () {
      d(`Loading canned FileChangedCache from ${ file }`);

      let buf = yield _promise.pfs.readFile(file);
      return FileChangedCache.loadFromData(JSON.parse((yield _promise.pzlib.gunzip(buf))), appRoot, failOnCacheMiss);
    })();
  }

  /**
   * Returns information about a given file, including its hash. This method is
   * the main method for this cache.
   *
   * @param  {string} absoluteFilePath  The path to a file to retrieve info on.
   *
   * @return {Promise<Object>}
   *
   * @property {string} hash  The SHA1 hash of the file
   * @property {boolean} isMinified  True if the file is minified
   * @property {boolean} isInNodeModules  True if the file is in a library directory
   * @property {boolean} hasSourceMap  True if the file has a source map
   * @property {boolean} isFileBinary  True if the file is not a text file
   * @property {Buffer} binaryData (optional)  The buffer that was read if the file
   *                                           was binary and there was a cache miss.
   * @property {string} code (optional)  The string that was read if the file
   *                                     was text and there was a cache miss
   */
  getHashForPath(absoluteFilePath) {
    var _this = this;

    return _asyncToGenerator(function* () {
      let cacheKey = (0, _sanitizePaths2.default)(absoluteFilePath);
      if (_this.appRoot) {
        cacheKey = cacheKey.replace(_this.appRoot, '');
      }

      // NB: We do this because x-require will include an absolute path from the
      // original built app and we need to still grok it
      if (_this.originalAppRoot) {
        cacheKey = cacheKey.replace(_this.originalAppRoot, '');
      }

      let cacheEntry = _this.changeCache[cacheKey];

      if (_this.failOnCacheMiss) {
        if (!cacheEntry) {
          d(`Tried to read file cache entry for ${ absoluteFilePath }`);
          d(`cacheKey: ${ cacheKey }, appRoot: ${ _this.appRoot }, originalAppRoot: ${ _this.originalAppRoot }`);
          throw new Error(`Asked for ${ absoluteFilePath } but it was not precompiled!`);
        }

        return cacheEntry.info;
      }

      let stat = yield _promise.pfs.stat(absoluteFilePath);
      let ctime = stat.ctime.getTime();
      let size = stat.size;
      if (!stat || !stat.isFile()) throw new Error(`Can't stat ${ absoluteFilePath }`);

      if (cacheEntry) {
        if (cacheEntry.ctime >= ctime && cacheEntry.size === size) {
          return cacheEntry.info;
        }

        d(`Invalidating cache entry: ${ cacheEntry.ctime } === ${ ctime } && ${ cacheEntry.size } === ${ size }`);
        delete _this.changeCache.cacheEntry;
      }

      var _ref = yield _this.calculateHashForFile(absoluteFilePath);

      let digest = _ref.digest,
          sourceCode = _ref.sourceCode,
          binaryData = _ref.binaryData;


      let info = {
        hash: digest,
        isMinified: FileChangedCache.contentsAreMinified(sourceCode || ''),
        isInNodeModules: FileChangedCache.isInNodeModules(absoluteFilePath),
        hasSourceMap: FileChangedCache.hasSourceMap(sourceCode || ''),
        isFileBinary: !!binaryData
      };

      _this.changeCache[cacheKey] = { ctime, size, info };
      d(`Cache entry for ${ cacheKey }: ${ JSON.stringify(_this.changeCache[cacheKey]) }`);

      if (binaryData) {
        return Object.assign({ binaryData }, info);
      } else {
        return Object.assign({ sourceCode }, info);
      }
    })();
  }

  /**
   * Returns data that can passed to {@link loadFromData} to rehydrate this cache.
   *
   * @return {Object}
   */
  getSavedData() {
    return { changeCache: this.changeCache, appRoot: this.appRoot };
  }

  /**
   * Serializes this object's data to a file.
   *
   * @param {string} filePath  The path to save data to.
   *
   * @return {Promise} Completion.
   */
  save(filePath) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      let toSave = _this2.getSavedData();

      let buf = yield _promise.pzlib.gzip(new Buffer(JSON.stringify(toSave)));
      yield _promise.pfs.writeFile(filePath, buf);
    })();
  }

  calculateHashForFile(absoluteFilePath) {
    return _asyncToGenerator(function* () {
      let buf = yield _promise.pfs.readFile(absoluteFilePath);
      let encoding = FileChangedCache.detectFileEncoding(buf);

      if (!encoding) {
        let digest = _crypto2.default.createHash('sha1').update(buf).digest('hex');
        return { sourceCode: null, digest, binaryData: buf };
      }

      let sourceCode = yield _promise.pfs.readFile(absoluteFilePath, encoding);
      let digest = _crypto2.default.createHash('sha1').update(sourceCode, 'utf8').digest('hex');

      return { sourceCode, digest, binaryData: null };
    })();
  }

  getHashForPathSync(absoluteFilePath) {
    let cacheKey = (0, _sanitizePaths2.default)(absoluteFilePath);
    if (this.appRoot) {
      cacheKey = cacheKey.replace(this.appRoot, '');
    }

    // NB: We do this because x-require will include an absolute path from the
    // original built app and we need to still grok it
    if (this.originalAppRoot) {
      cacheKey = cacheKey.replace(this.originalAppRoot, '');
    }

    if (this.realAppRoot) {
      cacheKey = cacheKey.replace(this.realAppRoot, '');
    }

    let cacheEntry = this.changeCache[cacheKey];

    if (this.failOnCacheMiss) {
      if (!cacheEntry) {
        d(`Tried to read file cache entry for ${ absoluteFilePath }`);
        d(`cacheKey: ${ cacheKey }, appRoot: ${ this.appRoot }, originalAppRoot: ${ this.originalAppRoot }`);
        throw new Error(`Asked for ${ absoluteFilePath } but it was not precompiled!`);
      }

      return cacheEntry.info;
    }

    let stat = _fs2.default.statSync(absoluteFilePath);
    let ctime = stat.ctime.getTime();
    let size = stat.size;
    if (!stat || !stat.isFile()) throw new Error(`Can't stat ${ absoluteFilePath }`);

    if (cacheEntry) {
      if (cacheEntry.ctime >= ctime && cacheEntry.size === size) {
        return cacheEntry.info;
      }

      d(`Invalidating cache entry: ${ cacheEntry.ctime } === ${ ctime } && ${ cacheEntry.size } === ${ size }`);
      delete this.changeCache.cacheEntry;
    }

    var _calculateHashForFile = this.calculateHashForFileSync(absoluteFilePath);

    let digest = _calculateHashForFile.digest,
        sourceCode = _calculateHashForFile.sourceCode,
        binaryData = _calculateHashForFile.binaryData;


    let info = {
      hash: digest,
      isMinified: FileChangedCache.contentsAreMinified(sourceCode || ''),
      isInNodeModules: FileChangedCache.isInNodeModules(absoluteFilePath),
      hasSourceMap: FileChangedCache.hasSourceMap(sourceCode || ''),
      isFileBinary: !!binaryData
    };

    this.changeCache[cacheKey] = { ctime, size, info };
    d(`Cache entry for ${ cacheKey }: ${ JSON.stringify(this.changeCache[cacheKey]) }`);

    if (binaryData) {
      return Object.assign({ binaryData }, info);
    } else {
      return Object.assign({ sourceCode }, info);
    }
  }

  saveSync(filePath) {
    let toSave = this.getSavedData();

    let buf = _zlib2.default.gzipSync(new Buffer(JSON.stringify(toSave)));
    _fs2.default.writeFileSync(filePath, buf);
  }

  calculateHashForFileSync(absoluteFilePath) {
    let buf = _fs2.default.readFileSync(absoluteFilePath);
    let encoding = FileChangedCache.detectFileEncoding(buf);

    if (!encoding) {
      let digest = _crypto2.default.createHash('sha1').update(buf).digest('hex');
      return { sourceCode: null, digest, binaryData: buf };
    }

    let sourceCode = _fs2.default.readFileSync(absoluteFilePath, encoding);
    let digest = _crypto2.default.createHash('sha1').update(sourceCode, 'utf8').digest('hex');

    return { sourceCode, digest, binaryData: null };
  }

  /**
   * Determines via some statistics whether a file is likely to be minified.
   *
   * @private
   */
  static contentsAreMinified(source) {
    let length = source.length;
    if (length > 1024) length = 1024;

    let newlineCount = 0;

    // Roll through the characters and determine the average line length
    for (let i = 0; i < source.length; i++) {
      if (source[i] === '\n') newlineCount++;
    }

    // No Newlines? Any file other than a super small one is minified
    if (newlineCount === 0) {
      return length > 80;
    }

    let avgLineLength = length / newlineCount;
    return avgLineLength > 80;
  }

  /**
   * Determines whether a path is in node_modules or the Electron init code
   *
   * @private
   */
  static isInNodeModules(filePath) {
    return !!(filePath.match(/(node_modules|bower_components)[\\\/]/i) || filePath.match(/(atom|electron)\.asar/));
  }

  /**
   * Returns whether a file has an inline source map
   *
   * @private
   */
  static hasSourceMap(sourceCode) {
    const trimmed = sourceCode.trim();
    return trimmed.lastIndexOf('//# sourceMap') > trimmed.lastIndexOf('\n');
  }

  /**
   * Determines the encoding of a file from the two most common encodings by trying
   * to decode it then looking for encoding errors
   *
   * @private
   */
  static detectFileEncoding(buffer) {
    if (buffer.length < 1) return false;
    let buf = buffer.length < 4096 ? buffer : buffer.slice(0, 4096);

    const encodings = ['utf8', 'utf16le'];

    let encoding;
    if (buffer.length <= 128) {
      encoding = encodings.find(x => Buffer.compare(new Buffer(buffer.toString(), x), buffer) === 0);
    } else {
      encoding = encodings.find(x => !FileChangedCache.containsControlCharacters(buf.toString(x)));
    }

    return encoding;
  }

  /**
   * Determines whether a string is likely to be poorly encoded by looking for
   * control characters above a certain threshold
   *
   * @private
   */
  static containsControlCharacters(str) {
    let controlCount = 0;
    let spaceCount = 0;
    let threshold = 2;
    if (str.length > 64) threshold = 4;
    if (str.length > 512) threshold = 8;

    for (let i = 0; i < str.length; i++) {
      let c = str.charCodeAt(i);
      if (c === 65536 || c < 8) controlCount++;
      if (c > 14 && c < 32) controlCount++;
      if (c === 32) spaceCount++;

      if (controlCount > threshold) return true;
    }

    if (spaceCount < threshold) return true;

    if (controlCount === 0) return false;
    return controlCount / str.length < 0.02;
  }
}
exports.default = FileChangedCache;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9maWxlLWNoYW5nZS1jYWNoZS5qcyJdLCJuYW1lcyI6WyJkIiwicmVxdWlyZSIsIkZpbGVDaGFuZ2VkQ2FjaGUiLCJjb25zdHJ1Y3RvciIsImFwcFJvb3QiLCJmYWlsT25DYWNoZU1pc3MiLCJjaGFuZ2VDYWNoZSIsImxvYWRGcm9tRGF0YSIsImRhdGEiLCJyZXQiLCJvcmlnaW5hbEFwcFJvb3QiLCJsb2FkRnJvbUZpbGUiLCJmaWxlIiwiYnVmIiwicmVhZEZpbGUiLCJKU09OIiwicGFyc2UiLCJndW56aXAiLCJnZXRIYXNoRm9yUGF0aCIsImFic29sdXRlRmlsZVBhdGgiLCJjYWNoZUtleSIsInJlcGxhY2UiLCJjYWNoZUVudHJ5IiwiRXJyb3IiLCJpbmZvIiwic3RhdCIsImN0aW1lIiwiZ2V0VGltZSIsInNpemUiLCJpc0ZpbGUiLCJjYWxjdWxhdGVIYXNoRm9yRmlsZSIsImRpZ2VzdCIsInNvdXJjZUNvZGUiLCJiaW5hcnlEYXRhIiwiaGFzaCIsImlzTWluaWZpZWQiLCJjb250ZW50c0FyZU1pbmlmaWVkIiwiaXNJbk5vZGVNb2R1bGVzIiwiaGFzU291cmNlTWFwIiwiaXNGaWxlQmluYXJ5Iiwic3RyaW5naWZ5IiwiT2JqZWN0IiwiYXNzaWduIiwiZ2V0U2F2ZWREYXRhIiwic2F2ZSIsImZpbGVQYXRoIiwidG9TYXZlIiwiZ3ppcCIsIkJ1ZmZlciIsIndyaXRlRmlsZSIsImVuY29kaW5nIiwiZGV0ZWN0RmlsZUVuY29kaW5nIiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsImdldEhhc2hGb3JQYXRoU3luYyIsInJlYWxBcHBSb290Iiwic3RhdFN5bmMiLCJjYWxjdWxhdGVIYXNoRm9yRmlsZVN5bmMiLCJzYXZlU3luYyIsImd6aXBTeW5jIiwid3JpdGVGaWxlU3luYyIsInJlYWRGaWxlU3luYyIsInNvdXJjZSIsImxlbmd0aCIsIm5ld2xpbmVDb3VudCIsImkiLCJhdmdMaW5lTGVuZ3RoIiwibWF0Y2giLCJ0cmltbWVkIiwidHJpbSIsImxhc3RJbmRleE9mIiwiYnVmZmVyIiwic2xpY2UiLCJlbmNvZGluZ3MiLCJmaW5kIiwieCIsImNvbXBhcmUiLCJ0b1N0cmluZyIsImNvbnRhaW5zQ29udHJvbENoYXJhY3RlcnMiLCJzdHIiLCJjb250cm9sQ291bnQiLCJzcGFjZUNvdW50IiwidGhyZXNob2xkIiwiYyIsImNoYXJDb2RlQXQiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7OztBQUVBLE1BQU1BLElBQUlDLFFBQVEsZ0JBQVIsRUFBMEIsb0NBQTFCLENBQVY7O0FBRUE7Ozs7Ozs7Ozs7O0FBV2UsTUFBTUMsZ0JBQU4sQ0FBdUI7QUFDcENDLGNBQVlDLE9BQVosRUFBNEM7QUFBQSxRQUF2QkMsZUFBdUIsdUVBQVAsS0FBTzs7QUFDMUMsU0FBS0QsT0FBTCxHQUFlLDZCQUFpQkEsT0FBakIsQ0FBZjs7QUFFQSxTQUFLQyxlQUFMLEdBQXVCQSxlQUF2QjtBQUNBLFNBQUtDLFdBQUwsR0FBbUIsRUFBbkI7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7OztBQWFBLFNBQU9DLFlBQVAsQ0FBb0JDLElBQXBCLEVBQTBCSixPQUExQixFQUF5RDtBQUFBLFFBQXRCQyxlQUFzQix1RUFBTixJQUFNOztBQUN2RCxRQUFJSSxNQUFNLElBQUlQLGdCQUFKLENBQXFCRSxPQUFyQixFQUE4QkMsZUFBOUIsQ0FBVjtBQUNBSSxRQUFJSCxXQUFKLEdBQWtCRSxLQUFLRixXQUF2QjtBQUNBRyxRQUFJQyxlQUFKLEdBQXNCRixLQUFLSixPQUEzQjs7QUFFQSxXQUFPSyxHQUFQO0FBQ0Q7O0FBR0Q7Ozs7Ozs7Ozs7Ozs7QUFhQSxTQUFhRSxZQUFiLENBQTBCQyxJQUExQixFQUFnQ1IsT0FBaEMsRUFBK0Q7QUFBQSxRQUF0QkMsZUFBc0IsdUVBQU4sSUFBTTtBQUFBO0FBQzdETCxRQUFHLHlDQUF1Q1ksSUFBSyxHQUEvQzs7QUFFQSxVQUFJQyxNQUFNLE1BQU0sYUFBSUMsUUFBSixDQUFhRixJQUFiLENBQWhCO0FBQ0Es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QixPQUFPLElBQVA7QUFDL0I7O0FBRUQsUUFBSUQsYUFBYUMsU0FBakIsRUFBNEIsT0FBTyxJQUFQOztBQUU1QixRQUFJRixpQkFBaUIsQ0FBckIsRUFBd0IsT0FBTyxLQUFQO0FBQ3hCLFdBQVFBLGVBQWVELElBQUloQixNQUFwQixHQUE4QixJQUFyQztBQUNEO0FBM1ZtQztrQkFBakI3RCxnQiIsImZpbGUiOiJmaWxlLWNoYW5nZS1jYWNoZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCB6bGliIGZyb20gJ3psaWInO1xyXG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XHJcbmltcG9ydCB7cGZzLCBwemxpYn0gZnJvbSAnLi9wcm9taXNlJztcclxuaW1wb3J0IHNhbml0aXplRmlsZVBhdGggZnJvbSAnLi9zYW5pdGl6ZS1wYXRocyc7XHJcblxyXG5jb25zdCBkID0gcmVxdWlyZSgnZGVidWctZWxlY3Ryb24nKSgnZWxlY3Ryb24tY29tcGlsZTpmaWxlLWNoYW5nZS1jYWNoZScpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgY2FjaGVzIGluZm9ybWF0aW9uIGFib3V0IGZpbGVzIGFuZCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhleSBoYXZlXHJcbiAqIGNoYW5nZWQgY29udGVudHMgb3Igbm90LiBNb3N0IGltcG9ydGFudGx5LCB0aGlzIGNsYXNzIGNhY2hlcyB0aGUgaGFzaCBvZiBzZWVuXHJcbiAqIGZpbGVzIHNvIHRoYXQgYXQgZGV2ZWxvcG1lbnQgdGltZSwgd2UgZG9uJ3QgaGF2ZSB0byByZWNhbGN1bGF0ZSB0aGVtIGNvbnN0YW50bHkuXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgaXMgYWxzbyB0aGUgY29yZSBvZiBob3cgZWxlY3Ryb24tY29tcGlsZSBydW5zIHF1aWNrbHkgaW4gcHJvZHVjdGlvblxyXG4gKiBtb2RlIC0gYWZ0ZXIgcHJlY29tcGlsYXRpb24sIHRoZSBjYWNoZSBpcyBzZXJpYWxpemVkIGFsb25nIHdpdGggdGhlIHJlc3Qgb2YgdGhlXHJcbiAqIGRhdGEgaW4ge0BsaW5rIENvbXBpbGVySG9zdH0sIHNvIHRoYXQgd2hlbiB3ZSBsb2FkIHRoZSBhcHAgaW4gcHJvZHVjdGlvbiBtb2RlLFxyXG4gKiB3ZSBkb24ndCBlbmQgdXAgY2FsY3VsYXRpbmcgaGFzaGVzIG9mIGZpbGUgY29udGVudCBhdCBhbGwsIG9ubHkgdXNpbmcgdGhlIGNvbnRlbnRzXHJcbiAqIG9mIHRoaXMgY2FjaGUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWxlQ2hhbmdlZENhY2hlIHtcclxuICBjb25zdHJ1Y3RvcihhcHBSb290LCBmYWlsT25DYWNoZU1pc3M9ZmFsc2UpIHtcclxuICAgIHRoaXMuYXBwUm9vdCA9IHNhbml0aXplRmlsZVBhdGgoYXBwUm9vdCk7XHJcblxyXG4gICAgdGhpcy5mYWlsT25DYWNoZU1pc3MgPSBmYWlsT25DYWNoZU1pc3M7XHJcbiAgICB0aGlzLmNoYW5nZUNhY2hlID0ge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbGxvd3MgeW91IHRvIGNyZWF0ZSBhIEZpbGVDaGFuZ2VkQ2FjaGUgZnJvbSBzZXJpYWxpemVkIGRhdGEgc2F2ZWQgZnJvbVxyXG4gICAqIHtAbGluayBnZXRTYXZlZERhdGF9LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhICBTYXZlZCBkYXRhIGZyb20gZ2V0U2F2ZWREYXRhLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhcHBSb290ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSBmb3IgeW91ciBhcHBsaWNhdGlvbiAoaS5lLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZmFpbE9uQ2FjaGVNaXNzIChvcHRpb25hbCkgIElmIFRydWUsIGNhY2hlIG1pc3NlcyB3aWxsIHRocm93LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RmlsZUNoYW5nZWRDYWNoZX1cclxuICAgKi9cclxuICBzdGF0aWMgbG9hZEZyb21EYXRhKGRhdGEsIGFwcFJvb3QsIGZhaWxPbkNhY2hlTWlzcz10cnVlKSB7XHJcbiAgICBsZXQgcmV0ID0gbmV3IEZpbGVDaGFuZ2VkQ2FjaGUoYXBwUm9vdCwgZmFpbE9uQ2FjaGVNaXNzKTtcclxuICAgIHJldC5jaGFuZ2VDYWNoZSA9IGRhdGEuY2hhbmdlQ2FjaGU7XHJcbiAgICByZXQub3JpZ2luYWxBcHBSb290ID0gZGF0YS5hcHBSb290O1xyXG5cclxuICAgIHJldHVybiByZXQ7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQWxsb3dzIHlvdSB0byBjcmVhdGUgYSBGaWxlQ2hhbmdlZENhY2hlIGZyb20gc2VyaWFsaXplZCBkYXRhIHNhdmVkIGZyb21cclxuICAgKiB7QGxpbmsgc2F2ZX0uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGUgIFNhdmVkIGRhdGEgZnJvbSBzYXZlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhcHBSb290ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSBmb3IgeW91ciBhcHBsaWNhdGlvbiAoaS5lLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZmFpbE9uQ2FjaGVNaXNzIChvcHRpb25hbCkgIElmIFRydWUsIGNhY2hlIG1pc3NlcyB3aWxsIHRocm93LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UHJvbWlzZTxGaWxlQ2hhbmdlZENhY2hlPn1cclxuICAgKi9cclxuICBzdGF0aWMgYXN5bmMgbG9hZEZyb21GaWxlKGZpbGUsIGFwcFJvb3QsIGZhaWxPbkNhY2hlTWlzcz10cnVlKSB7XHJcbiAgICBkKGBMb2FkaW5nIGNhbm5lZCBGaWxlQ2hhbmdlZENhY2hlIGZyb20gJHtmaWxlfWApO1xyXG5cclxuICAgIGxldCBidWYgPSBhd2FpdCBwZnMucmVhZEZpbGUoZmlsZSk7XHJcbiAgICByZXR1cm4gRmlsZUNoYW5nZWRDYWNoZS5sb2FkRnJvbURhdGEoSlNPTi5wYXJzZShhd2FpdCBwemxpYi5ndW56aXAoYnVmKSksIGFwcFJvb3QsIGZhaWxPbkNhY2hlTWlzcyk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCBhIGdpdmVuIGZpbGUsIGluY2x1ZGluZyBpdHMgaGFzaC4gVGhpcyBtZXRob2QgaXNcclxuICAgKiB0aGUgbWFpbiBtZXRob2QgZm9yIHRoaXMgY2FjaGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGFic29sdXRlRmlsZVBhdGggIFRoZSBwYXRoIHRvIGEgZmlsZSB0byByZXRyaWV2ZSBpbmZvIG9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fVxyXG4gICAqXHJcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGhhc2ggIFRoZSBTSEExIGhhc2ggb2YgdGhlIGZpbGVcclxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzTWluaWZpZWQgIFRydWUgaWYgdGhlIGZpbGUgaXMgbWluaWZpZWRcclxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzSW5Ob2RlTW9kdWxlcyAgVHJ1ZSBpZiB0aGUgZmlsZSBpcyBpbiBhIGxpYnJhcnkgZGlyZWN0b3J5XHJcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBoYXNTb3VyY2VNYXAgIFRydWUgaWYgdGhlIGZpbGUgaGFzIGEgc291cmNlIG1hcFxyXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNGaWxlQmluYXJ5ICBUcnVlIGlmIHRoZSBmaWxlIGlzIG5vdCBhIHRleHQgZmlsZVxyXG4gICAqIEBwcm9wZXJ0eSB7QnVmZmVyfSBiaW5hcnlEYXRhIChvcHRpb25hbCkgIFRoZSBidWZmZXIgdGhhdCB3YXMgcmVhZCBpZiB0aGUgZmlsZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcyBiaW5hcnkgYW5kIHRoZXJlIHdhcyBhIGNhY2hlIG1pc3MuXHJcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgKG9wdGlvbmFsKSAgVGhlIHN0cmluZyB0aGF0IHdhcyByZWFkIGlmIHRoZSBmaWxlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzIHRleHQgYW5kIHRoZXJlIHdhcyBhIGNhY2hlIG1pc3NcclxuICAgKi9cclxuICBhc3luYyBnZXRIYXNoRm9yUGF0aChhYnNvbHV0ZUZpbGVQYXRoKSB7XHJcbiAgICBsZXQgY2FjaGVLZXkgPSBzYW5pdGl6ZUZpbGVQYXRoKGFic29sdXRlRmlsZVBhdGgpO1xyXG4gICAgaWYgKHRoaXMuYXBwUm9vdCkge1xyXG4gICAgICBjYWNoZUtleSA9IGNhY2hlS2V5LnJlcGxhY2UodGhpcy5hcHBSb290LCAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTkI6IFdlIGRvIHRoaXMgYmVjYXVzZSB4LXJlcXVpcmUgd2lsbCBpbmNsdWRlIGFuIGFic29sdXRlIHBhdGggZnJvbSB0aGVcclxuICAgIC8vIG9yaWdpbmFsIGJ1aWx0IGFwcCBhbmQgd2UgbmVlZCB0byBzdGlsbCBncm9rIGl0XHJcbiAgICBpZiAodGhpcy5vcmlnaW5hbEFwcFJvb3QpIHtcclxuICAgICAgY2FjaGVLZXkgPSBjYWNoZUtleS5yZXBsYWNlKHRoaXMub3JpZ2luYWxBcHBSb290LCAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNhY2hlRW50cnkgPSB0aGlzLmNoYW5nZUNhY2hlW2NhY2hlS2V5XTtcclxuXHJcbiAgICBpZiAodGhpcy5mYWlsT25DYWNoZU1pc3MpIHtcclxuICAgICAgaWYgKCFjYWNoZUVudHJ5KSB7XHJcbiAgICAgICAgZChgVHJpZWQgdG8gcmVhZCBmaWxlIGNhY2hlIGVudHJ5IGZvciAke2Fic29sdXRlRmlsZVBhdGh9YCk7XHJcbiAgICAgICAgZChgY2FjaGVLZXk6ICR7Y2FjaGVLZXl9LCBhcHBSb290OiAke3RoaXMuYXBwUm9vdH0sIG9yaWdpbmFsQXBwUm9vdDogJHt0aGlzLm9yaWdpbmFsQXBwUm9vdH1gKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFza2VkIGZvciAke2Fic29sdXRlRmlsZVBhdGh9IGJ1dCBpdCB3YXMgbm90IHByZWNvbXBpbGVkIWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gY2FjaGVFbnRyeS5pbmZvO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBzdGF0ID0gYXdhaXQgcGZzLnN0YXQoYWJzb2x1dGVGaWxlUGF0aCk7XHJcbiAgICBsZXQgY3RpbWUgPSBzdGF0LmN0aW1lLmdldFRpbWUoKTtcclxuICAgIGxldCBzaXplID0gc3RhdC5zaXplO1xyXG4gICAgaWYgKCFzdGF0IHx8ICFzdGF0LmlzRmlsZSgpKSB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHN0YXQgJHthYnNvbHV0ZUZpbGVQYXRofWApO1xyXG5cclxuICAgIGlmIChjYWNoZUVudHJ5KSB7XHJcbiAgICAgIGlmIChjYWNoZUVudHJ5LmN0aW1lID49IGN0aW1lICYmIGNhY2hlRW50cnkuc2l6ZSA9PT0gc2l6ZSkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZUVudHJ5LmluZm87XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGQoYEludmFsaWRhdGluZyBjYWNoZSBlbnRyeTogJHtjYWNoZUVudHJ5LmN0aW1lfSA9PT0gJHtjdGltZX0gJiYgJHtjYWNoZUVudHJ5LnNpemV9ID09PSAke3NpemV9YCk7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLmNoYW5nZUNhY2hlLmNhY2hlRW50cnk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHtkaWdlc3QsIHNvdXJjZUNvZGUsIGJpbmFyeURhdGF9ID0gYXdhaXQgdGhpcy5jYWxjdWxhdGVIYXNoRm9yRmlsZShhYnNvbHV0ZUZpbGVQYXRoKTtcclxuXHJcbiAgICBsZXQgaW5mbyA9IHtcclxuICAgICAgaGFzaDogZGlnZXN0LFxyXG4gICAgICBpc01pbmlmaWVkOiBGaWxlQ2hhbmdlZENhY2hlLmNvbnRlbnRzQXJlTWluaWZpZWQoc291cmNlQ29kZSB8fCAnJyksXHJcbiAgICAgIGlzSW5Ob2RlTW9kdWxlczogRmlsZUNoYW5nZWRDYWNoZS5pc0luTm9kZU1vZHVsZXMoYWJzb2x1dGVGaWxlUGF0aCksXHJcbiAgICAgIGhhc1NvdXJjZU1hcDogRmlsZUNoYW5nZWRDYWNoZS5oYXNTb3VyY2VNYXAoc291cmNlQ29kZSB8fCAnJyksXHJcbiAgICAgIGlzRmlsZUJpbmFyeTogISFiaW5hcnlEYXRhXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY2hhbmdlQ2FjaGVbY2FjaGVLZXldID0geyBjdGltZSwgc2l6ZSwgaW5mbyB9O1xyXG4gICAgZChgQ2FjaGUgZW50cnkgZm9yICR7Y2FjaGVLZXl9OiAke0pTT04uc3RyaW5naWZ5KHRoaXMuY2hhbmdlQ2FjaGVbY2FjaGVLZXldKX1gKTtcclxuXHJcbiAgICBpZiAoYmluYXJ5RGF0YSkge1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7YmluYXJ5RGF0YX0sIGluZm8pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe3NvdXJjZUNvZGV9LCBpbmZvKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGRhdGEgdGhhdCBjYW4gcGFzc2VkIHRvIHtAbGluayBsb2FkRnJvbURhdGF9IHRvIHJlaHlkcmF0ZSB0aGlzIGNhY2hlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGdldFNhdmVkRGF0YSgpIHtcclxuICAgIHJldHVybiB7IGNoYW5nZUNhY2hlOiB0aGlzLmNoYW5nZUNhY2hlLCBhcHBSb290OiB0aGlzLmFwcFJvb3QgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlcmlhbGl6ZXMgdGhpcyBvYmplY3QncyBkYXRhIHRvIGEgZmlsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlUGF0aCAgVGhlIHBhdGggdG8gc2F2ZSBkYXRhIHRvLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX0gQ29tcGxldGlvbi5cclxuICAgKi9cclxuICBhc3luYyBzYXZlKGZpbGVQYXRoKSB7XHJcbiAgICBsZXQgdG9TYXZlID0gdGhpcy5nZXRTYXZlZERhdGEoKTtcclxuXHJcbiAgICBsZXQgYnVmID0gYXdhaXQgcHpsaWIuZ3ppcChuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KHRvU2F2ZSkpKTtcclxuICAgIGF3YWl0IHBmcy53cml0ZUZpbGUoZmlsZVBhdGgsIGJ1Zik7XHJcbiAgfVxyXG5cclxuICBhc3luYyBjYWxjdWxhdGVIYXNoRm9yRmlsZShhYnNvbHV0ZUZpbGVQYXRoKSB7XHJcbiAgICBsZXQgYnVmID0gYXdhaXQgcGZzLnJlYWRGaWxlKGFic29sdXRlRmlsZVBhdGgpO1xyXG4gICAgbGV0IGVuY29kaW5nID0gRmlsZUNoYW5nZWRDYWNoZS5kZXRlY3RGaWxlRW5jb2RpbmcoYnVmKTtcclxuXHJcbiAgICBpZiAoIWVuY29kaW5nKSB7XHJcbiAgICAgIGxldCBkaWdlc3QgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShidWYpLmRpZ2VzdCgnaGV4Jyk7XHJcbiAgICAgIHJldHVybiB7IHNvdXJjZUNvZGU6IG51bGwsIGRpZ2VzdCwgYmluYXJ5RGF0YTogYnVmIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHNvdXJjZUNvZGUgPSBhd2FpdCBwZnMucmVhZEZpbGUoYWJzb2x1dGVGaWxlUGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgbGV0IGRpZ2VzdCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKHNvdXJjZUNvZGUsICd1dGY4JykuZGlnZXN0KCdoZXgnKTtcclxuXHJcbiAgICByZXR1cm4ge3NvdXJjZUNvZGUsIGRpZ2VzdCwgYmluYXJ5RGF0YTogbnVsbCB9O1xyXG4gIH1cclxuXHJcbiAgZ2V0SGFzaEZvclBhdGhTeW5jKGFic29sdXRlRmlsZVBhdGgpIHtcclxuICAgIGxldCBjYWNoZUtleSA9IHNhbml0aXplRmlsZVBhdGgoYWJzb2x1dGVGaWxlUGF0aCk7XHJcbiAgICBpZiAodGhpcy5hcHBSb290KSB7XHJcbiAgICAgIGNhY2hlS2V5ID0gY2FjaGVLZXkucmVwbGFjZSh0aGlzLmFwcFJvb3QsICcnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOQjogV2UgZG8gdGhpcyBiZWNhdXNlIHgtcmVxdWlyZSB3aWxsIGluY2x1ZGUgYW4gYWJzb2x1dGUgcGF0aCBmcm9tIHRoZVxyXG4gICAgLy8gb3JpZ2luYWwgYnVpbHQgYXBwIGFuZCB3ZSBuZWVkIHRvIHN0aWxsIGdyb2sgaXRcclxuICAgIGlmICh0aGlzLm9yaWdpbmFsQXBwUm9vdCkge1xyXG4gICAgICBjYWNoZUtleSA9IGNhY2hlS2V5LnJlcGxhY2UodGhpcy5vcmlnaW5hbEFwcFJvb3QsICcnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5yZWFsQXBwUm9vdCkge1xyXG4gICAgICBjYWNoZUtleSA9IGNhY2hlS2V5LnJlcGxhY2UodGhpcy5yZWFsQXBwUm9vdCwgJycpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjYWNoZUVudHJ5ID0gdGhpcy5jaGFuZ2VDYWNoZVtjYWNoZUtleV07XHJcblxyXG4gICAgaWYgKHRoaXMuZmFpbE9uQ2FjaGVNaXNzKSB7XHJcbiAgICAgIGlmICghY2FjaGVFbnRyeSkge1xyXG4gICAgICAgIGQoYFRyaWVkIHRvIHJlYWQgZmlsZSBjYWNoZSBlbnRyeSBmb3IgJHthYnNvbHV0ZUZpbGVQYXRofWApO1xyXG4gICAgICAgIGQoYGNhY2hlS2V5OiAke2NhY2hlS2V5fSwgYXBwUm9vdDogJHt0aGlzLmFwcFJvb3R9LCBvcmlnaW5hbEFwcFJvb3Q6ICR7dGhpcy5vcmlnaW5hbEFwcFJvb3R9YCk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc2tlZCBmb3IgJHthYnNvbHV0ZUZpbGVQYXRofSBidXQgaXQgd2FzIG5vdCBwcmVjb21waWxlZCFgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNhY2hlRW50cnkuaW5mbztcclxuICAgIH1cclxuXHJcbiAgICBsZXQgc3RhdCA9IGZzLnN0YXRTeW5jKGFic29sdXRlRmlsZVBhdGgpO1xyXG4gICAgbGV0IGN0aW1lID0gc3RhdC5jdGltZS5nZXRUaW1lKCk7XHJcbiAgICBsZXQgc2l6ZSA9IHN0YXQuc2l6ZTtcclxuICAgIGlmICghc3RhdCB8fCAhc3RhdC5pc0ZpbGUoKSkgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzdGF0ICR7YWJzb2x1dGVGaWxlUGF0aH1gKTtcclxuXHJcbiAgICBpZiAoY2FjaGVFbnRyeSkge1xyXG4gICAgICBpZiAoY2FjaGVFbnRyeS5jdGltZSA+PSBjdGltZSAmJiBjYWNoZUVudHJ5LnNpemUgPT09IHNpemUpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVFbnRyeS5pbmZvO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkKGBJbnZhbGlkYXRpbmcgY2FjaGUgZW50cnk6ICR7Y2FjaGVFbnRyeS5jdGltZX0gPT09ICR7Y3RpbWV9ICYmICR7Y2FjaGVFbnRyeS5zaXplfSA9PT0gJHtzaXplfWApO1xyXG4gICAgICBkZWxldGUgdGhpcy5jaGFuZ2VDYWNoZS5jYWNoZUVudHJ5O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCB7ZGlnZXN0LCBzb3VyY2VDb2RlLCBiaW5hcnlEYXRhfSA9IHRoaXMuY2FsY3VsYXRlSGFzaEZvckZpbGVTeW5jKGFic29sdXRlRmlsZVBhdGgpO1xyXG5cclxuICAgIGxldCBpbmZvID0ge1xyXG4gICAgICBoYXNoOiBkaWdlc3QsXHJcbiAgICAgIGlzTWluaWZpZWQ6IEZpbGVDaGFuZ2VkQ2FjaGUuY29udGVudHNBcmVNaW5pZmllZChzb3VyY2VDb2RlIHx8ICcnKSxcclxuICAgICAgaXNJbk5vZGVNb2R1bGVzOiBGaWxlQ2hhbmdlZENhY2hlLmlzSW5Ob2RlTW9kdWxlcyhhYnNvbHV0ZUZpbGVQYXRoKSxcclxuICAgICAgaGFzU291cmNlTWFwOiBGaWxlQ2hhbmdlZENhY2hlLmhhc1NvdXJjZU1hcChzb3VyY2VDb2RlIHx8ICcnKSxcclxuICAgICAgaXNGaWxlQmluYXJ5OiAhIWJpbmFyeURhdGFcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5jaGFuZ2VDYWNoZVtjYWNoZUtleV0gPSB7IGN0aW1lLCBzaXplLCBpbmZvIH07XHJcbiAgICBkKGBDYWNoZSBlbnRyeSBmb3IgJHtjYWNoZUtleX06ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5jaGFuZ2VDYWNoZVtjYWNoZUtleV0pfWApO1xyXG5cclxuICAgIGlmIChiaW5hcnlEYXRhKSB7XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtiaW5hcnlEYXRhfSwgaW5mbyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7c291cmNlQ29kZX0sIGluZm8pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2F2ZVN5bmMoZmlsZVBhdGgpIHtcclxuICAgIGxldCB0b1NhdmUgPSB0aGlzLmdldFNhdmVkRGF0YSgpO1xyXG5cclxuICAgIGxldCBidWYgPSB6bGliLmd6aXBTeW5jKG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkodG9TYXZlKSkpO1xyXG4gICAgZnMud3JpdGVGaWxlU3luYyhmaWxlUGF0aCwgYnVmKTtcclxuICB9XHJcblxyXG4gIGNhbGN1bGF0ZUhhc2hGb3JGaWxlU3luYyhhYnNvbHV0ZUZpbGVQYXRoKSB7XHJcbiAgICBsZXQgYnVmID0gZnMucmVhZEZpbGVTeW5jKGFic29sdXRlRmlsZVBhdGgpO1xyXG4gICAgbGV0IGVuY29kaW5nID0gRmlsZUNoYW5nZWRDYWNoZS5kZXRlY3RGaWxlRW5jb2RpbmcoYnVmKTtcclxuXHJcbiAgICBpZiAoIWVuY29kaW5nKSB7XHJcbiAgICAgIGxldCBkaWdlc3QgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShidWYpLmRpZ2VzdCgnaGV4Jyk7XHJcbiAgICAgIHJldHVybiB7IHNvdXJjZUNvZGU6IG51bGwsIGRpZ2VzdCwgYmluYXJ5RGF0YTogYnVmfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgc291cmNlQ29kZSA9IGZzLnJlYWRGaWxlU3luYyhhYnNvbHV0ZUZpbGVQYXRoLCBlbmNvZGluZyk7XHJcbiAgICBsZXQgZGlnZXN0ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoc291cmNlQ29kZSwgJ3V0ZjgnKS5kaWdlc3QoJ2hleCcpO1xyXG5cclxuICAgIHJldHVybiB7c291cmNlQ29kZSwgZGlnZXN0LCBiaW5hcnlEYXRhOiBudWxsfTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHZpYSBzb21lIHN0YXRpc3RpY3Mgd2hldGhlciBhIGZpbGUgaXMgbGlrZWx5IHRvIGJlIG1pbmlmaWVkLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgY29udGVudHNBcmVNaW5pZmllZChzb3VyY2UpIHtcclxuICAgIGxldCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xyXG4gICAgaWYgKGxlbmd0aCA+IDEwMjQpIGxlbmd0aCA9IDEwMjQ7XHJcblxyXG4gICAgbGV0IG5ld2xpbmVDb3VudCA9IDA7XHJcblxyXG4gICAgLy8gUm9sbCB0aHJvdWdoIHRoZSBjaGFyYWN0ZXJzIGFuZCBkZXRlcm1pbmUgdGhlIGF2ZXJhZ2UgbGluZSBsZW5ndGhcclxuICAgIGZvcihsZXQgaT0wOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChzb3VyY2VbaV0gPT09ICdcXG4nKSBuZXdsaW5lQ291bnQrKztcclxuICAgIH1cclxuXHJcbiAgICAvLyBObyBOZXdsaW5lcz8gQW55IGZpbGUgb3RoZXIgdGhhbiBhIHN1cGVyIHNtYWxsIG9uZSBpcyBtaW5pZmllZFxyXG4gICAgaWYgKG5ld2xpbmVDb3VudCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gKGxlbmd0aCA+IDgwKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgYXZnTGluZUxlbmd0aCA9IGxlbmd0aCAvIG5ld2xpbmVDb3VudDtcclxuICAgIHJldHVybiAoYXZnTGluZUxlbmd0aCA+IDgwKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBwYXRoIGlzIGluIG5vZGVfbW9kdWxlcyBvciB0aGUgRWxlY3Ryb24gaW5pdCBjb2RlXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBpc0luTm9kZU1vZHVsZXMoZmlsZVBhdGgpIHtcclxuICAgIHJldHVybiAhIShmaWxlUGF0aC5tYXRjaCgvKG5vZGVfbW9kdWxlc3xib3dlcl9jb21wb25lbnRzKVtcXFxcXFwvXS9pKSB8fCBmaWxlUGF0aC5tYXRjaCgvKGF0b218ZWxlY3Ryb24pXFwuYXNhci8pKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBmaWxlIGhhcyBhbiBpbmxpbmUgc291cmNlIG1hcFxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgaGFzU291cmNlTWFwKHNvdXJjZUNvZGUpIHtcclxuICAgIGNvbnN0IHRyaW1tZWQgPSBzb3VyY2VDb2RlLnRyaW0oKTtcclxuICAgIHJldHVybiB0cmltbWVkLmxhc3RJbmRleE9mKCcvLyMgc291cmNlTWFwJykgPiB0cmltbWVkLmxhc3RJbmRleE9mKCdcXG4nKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgdGhlIGVuY29kaW5nIG9mIGEgZmlsZSBmcm9tIHRoZSB0d28gbW9zdCBjb21tb24gZW5jb2RpbmdzIGJ5IHRyeWluZ1xyXG4gICAqIHRvIGRlY29kZSBpdCB0aGVuIGxvb2tpbmcgZm9yIGVuY29kaW5nIGVycm9yc1xyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgZGV0ZWN0RmlsZUVuY29kaW5nKGJ1ZmZlcikge1xyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCAxKSByZXR1cm4gZmFsc2U7XHJcbiAgICBsZXQgYnVmID0gKGJ1ZmZlci5sZW5ndGggPCA0MDk2ID8gYnVmZmVyIDogYnVmZmVyLnNsaWNlKDAsIDQwOTYpKTtcclxuXHJcbiAgICBjb25zdCBlbmNvZGluZ3MgPSBbJ3V0ZjgnLCAndXRmMTZsZSddO1xyXG5cclxuICAgIGxldCBlbmNvZGluZztcclxuICAgIGlmIChidWZmZXIubGVuZ3RoIDw9IDEyOCkge1xyXG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5ncy5maW5kKHggPT5cclxuICAgICAgICBCdWZmZXIuY29tcGFyZShuZXcgQnVmZmVyKGJ1ZmZlci50b1N0cmluZygpLCB4KSwgYnVmZmVyKSA9PT0gMFxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZ3MuZmluZCh4ID0+ICFGaWxlQ2hhbmdlZENhY2hlLmNvbnRhaW5zQ29udHJvbENoYXJhY3RlcnMoYnVmLnRvU3RyaW5nKHgpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVuY29kaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3RyaW5nIGlzIGxpa2VseSB0byBiZSBwb29ybHkgZW5jb2RlZCBieSBsb29raW5nIGZvclxyXG4gICAqIGNvbnRyb2wgY2hhcmFjdGVycyBhYm92ZSBhIGNlcnRhaW4gdGhyZXNob2xkXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBjb250YWluc0NvbnRyb2xDaGFyYWN0ZXJzKHN0cikge1xyXG4gICAgbGV0IGNvbnRyb2xDb3VudCA9IDA7XHJcbiAgICBsZXQgc3BhY2VDb3VudCA9IDA7XHJcbiAgICBsZXQgdGhyZXNob2xkID0gMjtcclxuICAgIGlmIChzdHIubGVuZ3RoID4gNjQpIHRocmVzaG9sZCA9IDQ7XHJcbiAgICBpZiAoc3RyLmxlbmd0aCA+IDUxMikgdGhyZXNob2xkID0gODtcclxuXHJcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgaWYgKGMgPT09IDY1NTM2IHx8IGMgPCA4KSBjb250cm9sQ291bnQrKztcclxuICAgICAgaWYgKGMgPiAxNCAmJiBjIDwgMzIpIGNvbnRyb2xDb3VudCsrO1xyXG4gICAgICBpZiAoYyA9PT0gMzIpIHNwYWNlQ291bnQrKztcclxuXHJcbiAgICAgIGlmIChjb250cm9sQ291bnQgPiB0aHJlc2hvbGQpIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzcGFjZUNvdW50IDwgdGhyZXNob2xkKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICBpZiAoY29udHJvbENvdW50ID09PSAwKSByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gKGNvbnRyb2xDb3VudCAvIHN0ci5sZW5ndGgpIDwgMC4wMjtcclxuICB9XHJcbn1cclxuIl19