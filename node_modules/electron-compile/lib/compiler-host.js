'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mimeTypes = require('@paulcbetts/mime-types');

var _mimeTypes2 = _interopRequireDefault(_mimeTypes);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _promise = require('./promise');

var _forAllFiles = require('./for-all-files');

var _compileCache = require('./compile-cache');

var _compileCache2 = _interopRequireDefault(_compileCache);

var _fileChangeCache = require('./file-change-cache');

var _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);

var _readOnlyCompiler = require('./read-only-compiler');

var _readOnlyCompiler2 = _interopRequireDefault(_readOnlyCompiler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const d = require('debug-electron')('electron-compile:compiler-host');

require('./rig-mime-types').init();

// This isn't even my
const finalForms = {
  'text/javascript': true,
  'application/javascript': true,
  'text/html': true,
  'text/css': true,
  'image/svg+xml': true,
  'application/json': true
};

/**
 * This class is the top-level class that encapsulates all of the logic of
 * compiling and caching application code. If you're looking for a "Main class",
 * this is it.
 *
 * This class can be created directly but it is usually created via the methods
 * in config-parser, which will among other things, set up the compiler options
 * given a project root.
 *
 * CompilerHost is also the top-level class that knows how to serialize all of the
 * information necessary to recreate itself, either as a development host (i.e.
 * will allow cache misses and actual compilation), or as a read-only version of
 * itself for production.
 */
class CompilerHost {
  /**
   * Creates an instance of CompilerHost. You probably want to use the methods
   * in config-parser for development, or {@link createReadonlyFromConfiguration}
   * for production instead.
   *
   * @param  {string} rootCacheDir  The root directory to use for the cache
   *
   * @param  {Object} compilers  an Object whose keys are input MIME types and
   *                             whose values are instances of CompilerBase. Create
   *                             this via the {@link createCompilers} method in
   *                             config-parser.
   *
   * @param  {FileChangedCache} fileChangeCache  A file-change cache that is
   *                                             optionally pre-loaded.
   *
   * @param  {boolean} readOnlyMode  If True, cache misses will fail and
   *                                 compilation will not be attempted.
   *
   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
   *                                         which doesn't have a matching compiler,
   *                                         this compiler will be used instead. If
   *                                         null, will fail compilation. A good
   *                                         alternate fallback is the compiler for
   *                                         'text/plain', which is guaranteed to be
   *                                         present.
   */
  constructor(rootCacheDir, compilers, fileChangeCache, readOnlyMode) {
    let fallbackCompiler = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

    let compilersByMimeType = Object.assign({}, compilers);
    Object.assign(this, { rootCacheDir, compilersByMimeType, fileChangeCache, readOnlyMode, fallbackCompiler });
    this.appRoot = this.fileChangeCache.appRoot;

    this.cachesForCompilers = Object.keys(compilersByMimeType).reduce((acc, x) => {
      let compiler = compilersByMimeType[x];
      if (acc.has(compiler)) return acc;

      acc.set(compiler, _compileCache2.default.createFromCompiler(rootCacheDir, compiler, fileChangeCache, readOnlyMode));
      return acc;
    }, new Map());
  }

  /**
   * Creates a production-mode CompilerHost from the previously saved
   * configuration
   *
   * @param  {string} rootCacheDir  The root directory to use for the cache. This
   *                                cache must have cache information saved via
   *                                {@link saveConfiguration}
   *
   * @param  {string} appRoot  The top-level directory for your application (i.e.
   *                           the one which has your package.json).
   *
   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
   *                                         which doesn't have a matching compiler,
   *                                         this compiler will be used instead. If
   *                                         null, will fail compilation. A good
   *                                         alternate fallback is the compiler for
   *                                         'text/plain', which is guaranteed to be
   *                                         present.
   *
   * @return {Promise<CompilerHost>}  A read-only CompilerHost
   */
  static createReadonlyFromConfiguration(rootCacheDir, appRoot) {
    let fallbackCompiler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return _asyncToGenerator(function* () {
      let target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
      let buf = yield _promise.pfs.readFile(target);
      let info = JSON.parse((yield _promise.pzlib.gunzip(buf)));

      let fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, true);

      let compilers = Object.keys(info.compilers).reduce(function (acc, x) {
        let cur = info.compilers[x];
        acc[x] = new _readOnlyCompiler2.default(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);

        return acc;
      }, {});

      return new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler);
    })();
  }

  /**
   * Creates a development-mode CompilerHost from the previously saved
   * configuration.
   *
   * @param  {string} rootCacheDir  The root directory to use for the cache. This
   *                                cache must have cache information saved via
   *                                {@link saveConfiguration}
   *
   * @param  {string} appRoot  The top-level directory for your application (i.e.
   *                           the one which has your package.json).
   *
   * @param  {Object} compilersByMimeType  an Object whose keys are input MIME
   *                                       types and whose values are instances
   *                                       of CompilerBase. Create this via the
   *                                       {@link createCompilers} method in
   *                                       config-parser.
   *
   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
   *                                         which doesn't have a matching compiler,
   *                                         this compiler will be used instead. If
   *                                         null, will fail compilation. A good
   *                                         alternate fallback is the compiler for
   *                                         'text/plain', which is guaranteed to be
   *                                         present.
   *
   * @return {Promise<CompilerHost>}  A read-only CompilerHost
   */
  static createFromConfiguration(rootCacheDir, appRoot, compilersByMimeType) {
    let fallbackCompiler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    return _asyncToGenerator(function* () {
      let target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
      let buf = yield _promise.pfs.readFile(target);
      let info = JSON.parse((yield _promise.pzlib.gunzip(buf)));

      let fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, false);

      Object.keys(info.compilers).forEach(function (x) {
        let cur = info.compilers[x];
        compilersByMimeType[x].compilerOptions = cur.compilerOptions;
      });

      return new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler);
    })();
  }

  /**
   * Saves the current compiler configuration to a file that
   * {@link createReadonlyFromConfiguration} can use to recreate the current
   * compiler environment
   *
   * @return {Promise}  Completion
   */
  saveConfiguration() {
    var _this = this;

    return _asyncToGenerator(function* () {
      let serializedCompilerOpts = Object.keys(_this.compilersByMimeType).reduce(function (acc, x) {
        let compiler = _this.compilersByMimeType[x];
        let Klass = Object.getPrototypeOf(compiler).constructor;

        let val = {
          name: Klass.name,
          inputMimeTypes: Klass.getInputMimeTypes(),
          compilerOptions: compiler.compilerOptions,
          compilerVersion: compiler.getCompilerVersion()
        };

        acc[x] = val;
        return acc;
      }, {});

      let info = {
        fileChangeCache: _this.fileChangeCache.getSavedData(),
        compilers: serializedCompilerOpts
      };

      let target = _path2.default.join(_this.rootCacheDir, 'compiler-info.json.gz');
      let buf = yield _promise.pzlib.gzip(new Buffer(JSON.stringify(info)));
      yield _promise.pfs.writeFile(target, buf);
    })();
  }

  /**
   * Compiles a file and returns the compiled result.
   *
   * @param  {string} filePath  The path to the file to compile
   *
   * @return {Promise<object>}  An Object with the compiled result
   *
   * @property {Object} hashInfo  The hash information returned from getHashForPath
   * @property {string} code  The source code if the file was a text file
   * @property {Buffer} binaryData  The file if it was a binary file
   * @property {string} mimeType  The MIME type saved in the cache.
   * @property {string[]} dependentFiles  The dependent files returned from
   *                                      compiling the file, if any.
   */
  compile(filePath) {
    return this.readOnlyMode ? this.compileReadOnly(filePath) : this.fullCompile(filePath);
  }

  /**
   * Handles compilation in read-only mode
   *
   * @private
   */
  compileReadOnly(filePath) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      // We guarantee that node_modules are always shipped directly
      let type = _mimeTypes2.default.lookup(filePath);
      if (_fileChangeCache2.default.isInNodeModules(filePath)) {
        return {
          mimeType: type || 'application/javascript',
          code: yield _promise.pfs.readFile(filePath, 'utf8')
        };
      }

      let hashInfo = yield _this2.fileChangeCache.getHashForPath(filePath);

      // NB: Here, we're basically only using the compiler here to find
      // the appropriate CompileCache
      let compiler = CompilerHost.shouldPassthrough(hashInfo) ? _this2.getPassthroughCompiler() : _this2.compilersByMimeType[type || '__lolnothere'];

      if (!compiler) {
        compiler = _this2.fallbackCompiler;

        var _ref = yield compiler.get(filePath);

        let code = _ref.code,
            binaryData = _ref.binaryData,
            mimeType = _ref.mimeType;

        return { code: code || binaryData, mimeType };
      }

      let cache = _this2.cachesForCompilers.get(compiler);

      var _ref2 = yield cache.get(filePath);

      let code = _ref2.code,
          binaryData = _ref2.binaryData,
          mimeType = _ref2.mimeType;


      code = code || binaryData;
      if (!code || !mimeType) {
        throw new Error(`Asked to compile ${ filePath } in production, is this file not precompiled?`);
      }

      return { code, mimeType };
    })();
  }

  /**
   * Handles compilation in read-write mode
   *
   * @private
   */
  fullCompile(filePath) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      d(`Compiling ${ filePath }`);

      let hashInfo = yield _this3.fileChangeCache.getHashForPath(filePath);
      let type = _mimeTypes2.default.lookup(filePath);

      if (hashInfo.isInNodeModules) {
        let code = hashInfo.sourceCode || (yield _promise.pfs.readFile(filePath, 'utf8'));
        code = yield CompilerHost.fixNodeModulesSourceMapping(code, filePath, _this3.fileChangeCache.appRoot);
        return { code, mimeType: type };
      }

      let compiler = CompilerHost.shouldPassthrough(hashInfo) ? _this3.getPassthroughCompiler() : _this3.compilersByMimeType[type || '__lolnothere'];

      if (!compiler) {
        d(`Falling back to passthrough compiler for ${ filePath }`);
        compiler = _this3.fallbackCompiler;
      }

      if (!compiler) {
        throw new Error(`Couldn't find a compiler for ${ filePath }`);
      }

      let cache = _this3.cachesForCompilers.get(compiler);
      return yield cache.getOrFetch(filePath, function (filePath, hashInfo) {
        return _this3.compileUncached(filePath, hashInfo, compiler);
      });
    })();
  }

  /**
   * Handles invoking compilers independent of caching
   *
   * @private
   */
  compileUncached(filePath, hashInfo, compiler) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      let inputMimeType = _mimeTypes2.default.lookup(filePath);

      if (hashInfo.isFileBinary) {
        return {
          binaryData: hashInfo.binaryData || (yield _promise.pfs.readFile(filePath)),
          mimeType: inputMimeType,
          dependentFiles: []
        };
      }

      let ctx = {};
      let code = hashInfo.sourceCode || (yield _promise.pfs.readFile(filePath, 'utf8'));

      if (!(yield compiler.shouldCompileFile(code, ctx))) {
        d(`Compiler returned false for shouldCompileFile: ${ filePath }`);
        return { code, mimeType: _mimeTypes2.default.lookup(filePath), dependentFiles: [] };
      }

      let dependentFiles = yield compiler.determineDependentFiles(code, filePath, ctx);

      d(`Using compiler options: ${ JSON.stringify(compiler.compilerOptions) }`);
      let result = yield compiler.compile(code, filePath, ctx);

      let shouldInlineHtmlify = inputMimeType !== 'text/html' && result.mimeType === 'text/html';

      let isPassthrough = result.mimeType === 'text/plain' || !result.mimeType || CompilerHost.shouldPassthrough(hashInfo);

      if (finalForms[result.mimeType] && !shouldInlineHtmlify || isPassthrough) {
        // Got something we can use in-browser, let's return it
        return Object.assign(result, { dependentFiles });
      } else {
        d(`Recursively compiling result of ${ filePath } with non-final MIME type ${ result.mimeType }, input was ${ inputMimeType }`);

        hashInfo = Object.assign({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);
        compiler = _this4.compilersByMimeType[result.mimeType || '__lolnothere'];

        if (!compiler) {
          d(`Recursive compile failed - intermediate result: ${ JSON.stringify(result) }`);

          throw new Error(`Compiling ${ filePath } resulted in a MIME type of ${ result.mimeType }, which we don't know how to handle`);
        }

        return yield _this4.compileUncached(`${ filePath }.${ _mimeTypes2.default.extension(result.mimeType || 'txt') }`, hashInfo, compiler);
      }
    })();
  }

  /**
   * Pre-caches an entire directory of files recursively. Usually used for
   * building custom compiler tooling.
   *
   * @param  {string} rootDirectory  The top-level directory to compile
   *
   * @param  {Function} shouldCompile (optional)  A Function which allows the
   *                                  caller to disable compiling certain files.
   *                                  It takes a fully-qualified path to a file,
   *                                  and should return a Boolean.
   *
   * @return {Promise}  Completion.
   */
  compileAll(rootDirectory) {
    var _this5 = this;

    let shouldCompile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return _asyncToGenerator(function* () {
      let should = shouldCompile || function () {
        return true;
      };

      yield (0, _forAllFiles.forAllFiles)(rootDirectory, function (f) {
        if (!should(f)) return;

        d(`Compiling ${ f }`);
        return _this5.compile(f, _this5.compilersByMimeType);
      });
    })();
  }

  /*
   * Sync Methods
   */

  compileSync(filePath) {
    return this.readOnlyMode ? this.compileReadOnlySync(filePath) : this.fullCompileSync(filePath);
  }

  static createReadonlyFromConfigurationSync(rootCacheDir, appRoot) {
    let fallbackCompiler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    let target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
    let buf = _fs2.default.readFileSync(target);
    let info = JSON.parse(_zlib2.default.gunzipSync(buf));

    let fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, true);

    let compilers = Object.keys(info.compilers).reduce((acc, x) => {
      let cur = info.compilers[x];
      acc[x] = new _readOnlyCompiler2.default(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);

      return acc;
    }, {});

    return new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler);
  }

  static createFromConfigurationSync(rootCacheDir, appRoot, compilersByMimeType) {
    let fallbackCompiler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    let target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
    let buf = _fs2.default.readFileSync(target);
    let info = JSON.parse(_zlib2.default.gunzipSync(buf));

    let fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, false);

    Object.keys(info.compilers).forEach(x => {
      let cur = info.compilers[x];
      compilersByMimeType[x].compilerOptions = cur.compilerOptions;
    });

    return new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler);
  }

  saveConfigurationSync() {
    let serializedCompilerOpts = Object.keys(this.compilersByMimeType).reduce((acc, x) => {
      let compiler = this.compilersByMimeType[x];
      let Klass = Object.getPrototypeOf(compiler).constructor;

      let val = {
        name: Klass.name,
        inputMimeTypes: Klass.getInputMimeTypes(),
        compilerOptions: compiler.compilerOptions,
        compilerVersion: compiler.getCompilerVersion()
      };

      acc[x] = val;
      return acc;
    }, {});

    let info = {
      fileChangeCache: this.fileChangeCache.getSavedData(),
      compilers: serializedCompilerOpts
    };

    let target = _path2.default.join(this.rootCacheDir, 'compiler-info.json.gz');
    let buf = _zlib2.default.gzipSync(new Buffer(JSON.stringify(info)));
    _fs2.default.writeFileSync(target, buf);
  }

  compileReadOnlySync(filePath) {
    // We guarantee that node_modules are always shipped directly
    let type = _mimeTypes2.default.lookup(filePath);
    if (_fileChangeCache2.default.isInNodeModules(filePath)) {
      return {
        mimeType: type || 'application/javascript',
        code: _fs2.default.readFileSync(filePath, 'utf8')
      };
    }

    let hashInfo = this.fileChangeCache.getHashForPathSync(filePath);

    // We guarantee that node_modules are always shipped directly
    if (hashInfo.isInNodeModules) {
      return {
        mimeType: type,
        code: hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8')
      };
    }

    // NB: Here, we're basically only using the compiler here to find
    // the appropriate CompileCache
    let compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

    if (!compiler) {
      compiler = this.fallbackCompiler;

      var _compiler$getSync = compiler.getSync(filePath);

      let code = _compiler$getSync.code,
          binaryData = _compiler$getSync.binaryData,
          mimeType = _compiler$getSync.mimeType;

      return { code: code || binaryData, mimeType };
    }

    let cache = this.cachesForCompilers.get(compiler);

    var _cache$getSync = cache.getSync(filePath);

    let code = _cache$getSync.code,
        binaryData = _cache$getSync.binaryData,
        mimeType = _cache$getSync.mimeType;


    code = code || binaryData;
    if (!code || !mimeType) {
      throw new Error(`Asked to compile ${ filePath } in production, is this file not precompiled?`);
    }

    return { code, mimeType };
  }

  fullCompileSync(filePath) {
    d(`Compiling ${ filePath }`);

    let hashInfo = this.fileChangeCache.getHashForPathSync(filePath);
    let type = _mimeTypes2.default.lookup(filePath);

    if (hashInfo.isInNodeModules) {
      let code = hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8');
      code = CompilerHost.fixNodeModulesSourceMappingSync(code, filePath, this.fileChangeCache.appRoot);
      return { code, mimeType: type };
    }

    let compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

    if (!compiler) {
      d(`Falling back to passthrough compiler for ${ filePath }`);
      compiler = this.fallbackCompiler;
    }

    if (!compiler) {
      throw new Error(`Couldn't find a compiler for ${ filePath }`);
    }

    let cache = this.cachesForCompilers.get(compiler);
    return cache.getOrFetchSync(filePath, (filePath, hashInfo) => this.compileUncachedSync(filePath, hashInfo, compiler));
  }

  compileUncachedSync(filePath, hashInfo, compiler) {
    let inputMimeType = _mimeTypes2.default.lookup(filePath);

    if (hashInfo.isFileBinary) {
      return {
        binaryData: hashInfo.binaryData || _fs2.default.readFileSync(filePath),
        mimeType: inputMimeType,
        dependentFiles: []
      };
    }

    let ctx = {};
    let code = hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8');

    if (!compiler.shouldCompileFileSync(code, ctx)) {
      d(`Compiler returned false for shouldCompileFile: ${ filePath }`);
      return { code, mimeType: _mimeTypes2.default.lookup(filePath), dependentFiles: [] };
    }

    let dependentFiles = compiler.determineDependentFilesSync(code, filePath, ctx);

    let result = compiler.compileSync(code, filePath, ctx);

    let shouldInlineHtmlify = inputMimeType !== 'text/html' && result.mimeType === 'text/html';

    let isPassthrough = result.mimeType === 'text/plain' || !result.mimeType || CompilerHost.shouldPassthrough(hashInfo);

    if (finalForms[result.mimeType] && !shouldInlineHtmlify || isPassthrough) {
      // Got something we can use in-browser, let's return it
      return Object.assign(result, { dependentFiles });
    } else {
      d(`Recursively compiling result of ${ filePath } with non-final MIME type ${ result.mimeType }, input was ${ inputMimeType }`);

      hashInfo = Object.assign({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);
      compiler = this.compilersByMimeType[result.mimeType || '__lolnothere'];

      if (!compiler) {
        d(`Recursive compile failed - intermediate result: ${ JSON.stringify(result) }`);

        throw new Error(`Compiling ${ filePath } resulted in a MIME type of ${ result.mimeType }, which we don't know how to handle`);
      }

      return this.compileUncachedSync(`${ filePath }.${ _mimeTypes2.default.extension(result.mimeType || 'txt') }`, hashInfo, compiler);
    }
  }

  compileAllSync(rootDirectory) {
    let shouldCompile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    let should = shouldCompile || function () {
      return true;
    };

    (0, _forAllFiles.forAllFilesSync)(rootDirectory, f => {
      if (!should(f)) return;
      return this.compileSync(f, this.compilersByMimeType);
    });
  }

  /*
   * Other stuff
   */

  /**
   * Returns the passthrough compiler
   *
   * @private
   */
  getPassthroughCompiler() {
    return this.compilersByMimeType['text/plain'];
  }

  /**
   * Determines whether we should even try to compile the content. Note that in
   * some cases, content will still be in cache even if this returns true, and
   * in other cases (isInNodeModules), we'll know explicitly to not even bother
   * looking in the cache.
   *
   * @private
   */
  static shouldPassthrough(hashInfo) {
    return hashInfo.isMinified || hashInfo.isInNodeModules || hashInfo.hasSourceMap || hashInfo.isFileBinary;
  }

  /**
   * Look at the code of a node modules and see the sourceMapping path.
   * If there is any, check the path and try to fix it with and
   * root relative path.
   * @private
   */
  static fixNodeModulesSourceMapping(sourceCode, sourcePath, appRoot) {
    return _asyncToGenerator(function* () {
      let regexSourceMapping = /\/\/#.*sourceMappingURL=(?!data:)([^"'].*)/i;
      let sourceMappingCheck = sourceCode.match(regexSourceMapping);

      if (sourceMappingCheck && sourceMappingCheck[1] && sourceMappingCheck[1] !== '') {
        let sourceMapPath = sourceMappingCheck[1];

        try {
          yield _promise.pfs.stat(sourceMapPath);
        } catch (error) {
          let normRoot = _path2.default.normalize(appRoot);
          let absPathToModule = _path2.default.dirname(sourcePath.replace(normRoot, '').substring(1));
          let newMapPath = _path2.default.join(absPathToModule, sourceMapPath);

          return sourceCode.replace(regexSourceMapping, `//# sourceMappingURL=${ newMapPath }`);
        }
      }

      return sourceCode;
    })();
  }

  /**
   * Look at the code of a node modules and see the sourceMapping path.
   * If there is any, check the path and try to fix it with and
   * root relative path.
   * @private
   */
  static fixNodeModulesSourceMappingSync(sourceCode, sourcePath, appRoot) {
    let regexSourceMapping = /\/\/#.*sourceMappingURL=(?!data:)([^"'].*)/i;
    let sourceMappingCheck = sourceCode.match(regexSourceMapping);

    if (sourceMappingCheck && sourceMappingCheck[1] && sourceMappingCheck[1] !== '') {
      let sourceMapPath = sourceMappingCheck[1];

      try {
        _fs2.default.statSync(sourceMapPath);
      } catch (error) {
        let normRoot = _path2.default.normalize(appRoot);
        let absPathToModule = _path2.default.dirname(sourcePath.replace(normRoot, '').substring(1));
        let newMapPath = _path2.default.join(absPathToModule, sourceMapPath);

        return sourceCode.replace(regexSourceMapping, `//# sourceMappingURL=${ newMapPath }`);
      }
    }

    return sourceCode;
  }
}
exports.default = CompilerHost;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21waWxlci1ob3N0LmpzIl0sIm5hbWVzIjpbImQiLCJyZXF1aXJlIiwiaW5pdCIsImZpbmFsRm9ybXMiLCJDb21waWxlckhvc3QiLCJjb25zdHJ1Y3RvciIsInJvb3RDYWNoZURpciIsImNvbXBpbGVycyIsImZpbGVDaGFuZ2VDYWNoZSIsInJlYWRPbmx5TW9kZSIsImZhbGxiYWNrQ29tcGlsZXIiLCJjb21waWxlcnNCeU1pbWVUeXBlIiwiT2JqZWN0IiwiYXNzaWduIiwiYXBwUm9vdCIsImNhY2hlc0ZvckNvbXBpbGVycyIsImtleXMiLCJyZWR1Y2UiLCJhY2MiLCJ4IiwiY29tcGlsZXIiLCJoYXMiLCJzZXQiLCJjcmVhdGVGcm9tQ29tcGlsZXIiLCJNYXAiLCJjcmVhdGVSZWFkb25seUZyb21Db25maWd1cmF0aW9uIiwidGFyZ2V0Iiwiam9pbiIsImJ1ZiIsInJlYWRGaWxlIiwiaW5mbyIsIkpTT04iLCJwYXJzZSIsImd1bnppcCIsImxvYWRGcm9tRGF0YSIsImN1ciIsIm5hbWUiLCJjb21waWxlclZlcnNpb24iLCJjb21waWxlck9wdGlvbnMiLCJpbnB1dE1pbWVUeXBlcyIsImNyZWF0ZUZyb21Db25maWd1cmF0aW9uIiwiZm9yRWFjaCIsInNhdmVDb25maWd1cmF0aW9uIiwic2VyaWFsaXplZENvbXBpbGVyT3B0cyIsIktsYXNzIiwiZ2V0UHJvdG90eXBlT2YiLCJ2YWwiLCJnZXRJbnB1dE1pbWVUeXBlcyIsImdldENvbXBpbGVyVmVyc2lvbiIsImdldFNhdmVkRGF0YSIsImd6aXAiLCJCdWZmZXIiLCJzdHJpbmdpZnkiLCJ3cml0ZUZpbGUiLCJjb21waWxlIiwiZmlsZVBhdGgiLCJjb21waWxlUmVhZE9ubHkiLCJmdWxsQ29tcGlsZSIsInR5cGUiLCJsb29rdXAiLCJpc0luTm9kZU1vZHVsZXMiLCJtaW1lVHlwZSIsImNvZGUiLCJoYXNoSW5mbyIsImdldEhhc2hGb3JQYXRoIiwic2hvdWxkUGFzc3Rocm91Z2giLCJnZXRQYXNzdGhyb3VnaENvbXBpbGVyIiwiZ2V0IiwiYmluYXJ5RGF0YSIsImNhY2hlIiwiRXJyb3IiLCJzb3VyY2VDb2RlIiwiZml4Tm9kZU1vZHVsZXNTb3VyY2VNYXBwaW5nIiwiZ2V0T3JGZXRjaCIsImNvbXBpbGVVbmNhY2hlZCIsImlucHV0TWltZVR5cGUiLCJpc0ZpbGVCaW5hcnkiLCJkZXBlbmRlbnRGaWxlcyIsImN0eCIsInNob3VsZENvbXBpbGVGaWxlIiwiZGV0ZXJtaW5lRGVwZW5kZW50RmlsZXMiLCJyZXN1bHQiLCJzaG91bGRJbmxpbmVIdG1saWZ5IiwiaXNQYXNzdGhyb3VnaCIsImV4dGVuc2lvbiIsImNvbXBpbGVBbGwiLCJyb290RGlyZWN0b3J5Iiwic2hvdWxkQ29tcGlsZSIsInNob3VsZCIsImYiLCJjb21waWxlU3luYyIsImNvbXBpbGVSZWFkT25seVN5bmMiLCJmdWxsQ29tcGlsZVN5bmMiLCJjcmVhdGVSZWFkb25seUZyb21Db25maWd1cmF0aW9uU3luYyIsInJlYWRGaWxlU3luYyIsImd1bnppcFN5bmMiLCJjcmVhdGVGcm9tQ29uZmlndXJhdGlvblN5bmMiLCJzYXZlQ29uZmlndXJhdGlvblN5bmMiLCJnemlwU3luYyIsIndyaXRlRmlsZVN5bmMiLCJnZXRIYXNoRm9yUGF0aFN5bmMiLCJnZXRTeW5jIiwiZml4Tm9kZU1vZHVsZXNTb3VyY2VNYXBwaW5nU3luYyIsImdldE9yRmV0Y2hTeW5jIiwiY29tcGlsZVVuY2FjaGVkU3luYyIsInNob3VsZENvbXBpbGVGaWxlU3luYyIsImRldGVybWluZURlcGVuZGVudEZpbGVzU3luYyIsImNvbXBpbGVBbGxTeW5jIiwiaXNNaW5pZmllZCIsImhhc1NvdXJjZU1hcCIsInNvdXJjZVBhdGgiLCJyZWdleFNvdXJjZU1hcHBpbmciLCJzb3VyY2VNYXBwaW5nQ2hlY2siLCJtYXRjaCIsInNvdXJjZU1hcFBhdGgiLCJzdGF0IiwiZXJyb3IiLCJub3JtUm9vdCIsIm5vcm1hbGl6ZSIsImFic1BhdGhUb01vZHVsZSIsImRpcm5hbWUiLCJyZXBsYWNlIiwi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bnQiOlsiaW1wb3J0IG1pbWVUeXBlcyBmcm9tICdAcGF1bGNiZXR0cy9taW1lLXR5cGVzJztcclxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQge3BmcywgcHpsaWJ9IGZyb20gJy4vcHJvbWlzZSc7XHJcblxyXG5pbXBvcnQge2ZvckFsbEZpbGVzLCBmb3JBbGxGaWxlc1N5bmN9IGZyb20gJy4vZm9yLWFsbC1maWxlcyc7XHJcbmltcG9ydCBDb21waWxlQ2FjaGUgZnJvbSAnLi9jb21waWxlLWNhY2hlJztcclxuaW1wb3J0IEZpbGVDaGFuZ2VkQ2FjaGUgZnJvbSAnLi9maWxlLWNoYW5nZS1jYWNoZSc7XHJcbmltcG9ydCBSZWFkT25seUNvbXBpbGVyIGZyb20gJy4vcmVhZC1vbmx5LWNvbXBpbGVyJztcclxuXHJcbmNvbnN0IGQgPSByZXF1aXJlKCdkZWJ1Zy1lbGVjdHJvbicpKCdlbGVjdHJvbi1jb21waWxlOmNvbXBpbGVyLWhvc3QnKTtcclxuXHJcbnJlcXVpcmUoJy4vcmlnLW1pbWUtdHlwZXMnKS5pbml0KCk7XHJcblxyXG4vLyBUaGlzIGlzbid0IGV2ZW4gbXlcclxuY29uc3QgZmluYWxGb3JtcyA9IHtcclxuICAndGV4dC9qYXZhc2NyaXB0JzogdHJ1ZSxcclxuICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc6IHRydWUsXHJcbiAgJ3RleHQvaHRtbCc6IHRydWUsXHJcbiAgJ3RleHQvY3NzJzogdHJ1ZSxcclxuICAnaW1hZ2Uvc3ZnK3htbCc6IHRydWUsXHJcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiB0cnVlXHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBpcyB0aGUgdG9wLWxldmVsIGNsYXNzIHRoYXQgZW5jYXBzdWxhdGVzIGFsbCBvZiB0aGUgbG9naWMgb2ZcclxuICogY29tcGlsaW5nIGFuZCBjYWNoaW5nIGFwcGxpY2F0aW9uIGNvZGUuIElmIHlvdSdyZSBsb29raW5nIGZvciBhIFwiTWFpbiBjbGFzc1wiLFxyXG4gKiB0aGlzIGlzIGl0LlxyXG4gKlxyXG4gKiBUaGlzIGNsYXNzIGNhbiBiZSBjcmVhdGVkIGRpcmVjdGx5IGJ1dCBpdCBpcyB1c3VhbGx5IGNyZWF0ZWQgdmlhIHRoZSBtZXRob2RzXHJcbiAqIGluIGNvbmZpZy1wYXJzZXIsIHdoaWNoIHdpbGwgYW1vbmcgb3RoZXIgdGhpbmdzLCBzZXQgdXAgdGhlIGNvbXBpbGVyIG9wdGlvbnNcclxuICogZ2l2ZW4gYSBwcm9qZWN0IHJvb3QuXHJcbiAqXHJcbiAqIENvbXBpbGVySG9zdCBpcyBhbHNvIHRoZSB0b3AtbGV2ZWwgY2xhc3MgdGhhdCBrbm93cyBob3cgdG8gc2VyaWFsaXplIGFsbCBvZiB0aGVcclxuICogaW5mb3JtYXRpb24gbmVjZXNzYXJ5IHRvIHJlY3JlYXRlIGl0c2VsZiwgZWl0aGVyIGFzIGEgZGV2ZWxvcG1lbnQgaG9zdCAoaS5lLlxyXG4gKiB3aWxsIGFsbG93IGNhY2hlIG1pc3NlcyBhbmQgYWN0dWFsIGNvbXBpbGF0aW9uKSwgb3IgYXMgYSByZWFkLW9ubHkgdmVyc2lvbiBvZlxyXG4gKiBpdHNlbGYgZm9yIHByb2R1Y3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21waWxlckhvc3Qge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ29tcGlsZXJIb3N0LiBZb3UgcHJvYmFibHkgd2FudCB0byB1c2UgdGhlIG1ldGhvZHNcclxuICAgKiBpbiBjb25maWctcGFyc2VyIGZvciBkZXZlbG9wbWVudCwgb3Ige0BsaW5rIGNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb259XHJcbiAgICogZm9yIHByb2R1Y3Rpb24gaW5zdGVhZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcm9vdENhY2hlRGlyICBUaGUgcm9vdCBkaXJlY3RvcnkgdG8gdXNlIGZvciB0aGUgY2FjaGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29tcGlsZXJzICBhbiBPYmplY3Qgd2hvc2Uga2V5cyBhcmUgaW5wdXQgTUlNRSB0eXBlcyBhbmRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hvc2UgdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgQ29tcGlsZXJCYXNlLiBDcmVhdGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB2aWEgdGhlIHtAbGluayBjcmVhdGVDb21waWxlcnN9IG1ldGhvZCBpblxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWctcGFyc2VyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7RmlsZUNoYW5nZWRDYWNoZX0gZmlsZUNoYW5nZUNhY2hlICBBIGZpbGUtY2hhbmdlIGNhY2hlIHRoYXQgaXNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsbHkgcHJlLWxvYWRlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IHJlYWRPbmx5TW9kZSAgSWYgVHJ1ZSwgY2FjaGUgbWlzc2VzIHdpbGwgZmFpbCBhbmRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGF0aW9uIHdpbGwgbm90IGJlIGF0dGVtcHRlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0NvbXBpbGVyQmFzZX0gZmFsbGJhY2tDb21waWxlciAob3B0aW9uYWwpICBXaGVuIGEgZmlsZSBpcyBjb21waWxlZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBkb2Vzbid0IGhhdmUgYSBtYXRjaGluZyBjb21waWxlcixcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBjb21waWxlciB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gSWZcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgd2lsbCBmYWlsIGNvbXBpbGF0aW9uLiBBIGdvb2RcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRlIGZhbGxiYWNrIGlzIHRoZSBjb21waWxlciBmb3JcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQvcGxhaW4nLCB3aGljaCBpcyBndWFyYW50ZWVkIHRvIGJlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnQuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iocm9vdENhY2hlRGlyLCBjb21waWxlcnMsIGZpbGVDaGFuZ2VDYWNoZSwgcmVhZE9ubHlNb2RlLCBmYWxsYmFja0NvbXBpbGVyID0gbnVsbCkge1xyXG4gICAgbGV0IGNvbXBpbGVyc0J5TWltZVR5cGUgPSBPYmplY3QuYXNzaWduKHt9LCBjb21waWxlcnMpO1xyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7cm9vdENhY2hlRGlyLCBjb21waWxlcnNCeU1pbWVUeXBlLCBmaWxlQ2hhbmdlQ2FjaGUsIHJlYWRPbmx5TW9kZSwgZmFsbGJhY2tDb21waWxlcn0pO1xyXG4gICAgdGhpcy5hcHBSb290ID0gdGhpcy5maWxlQ2hhbmdlQ2FjaGUuYXBwUm9vdDtcclxuXHJcbiAgICB0aGlzLmNhY2hlc0ZvckNvbXBpbGVycyA9IE9iamVjdC5rZXlzKGNvbXBpbGVyc0J5TWltZVR5cGUpLnJlZHVjZSgoYWNjLCB4KSA9PiB7XHJcbiAgICAgIGxldCBjb21waWxlciA9IGNvbXBpbGVyc0J5TWltZVR5cGVbeF07XHJcbiAgICAgIGlmIChhY2MuaGFzKGNvbXBpbGVyKSkgcmV0dXJuIGFjYztcclxuXHJcbiAgICAgIGFjYy5zZXQoXHJcbiAgICAgICAgY29tcGlsZXIsXHJcbiAgICAgICAgQ29tcGlsZUNhY2hlLmNyZWF0ZUZyb21Db21waWxlcihyb290Q2FjaGVEaXIsIGNvbXBpbGVyLCBmaWxlQ2hhbmdlQ2FjaGUsIHJlYWRPbmx5TW9kZSkpO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwgbmV3IE1hcCgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBwcm9kdWN0aW9uLW1vZGUgQ29tcGlsZXJIb3N0IGZyb20gdGhlIHByZXZpb3VzbHkgc2F2ZWRcclxuICAgKiBjb25maWd1cmF0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAgVGhlIHJvb3QgZGlyZWN0b3J5IHRvIHVzZSBmb3IgdGhlIGNhY2hlLiBUaGlzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlIG11c3QgaGF2ZSBjYWNoZSBpbmZvcm1hdGlvbiBzYXZlZCB2aWFcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIHNhdmVDb25maWd1cmF0aW9ufVxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhcHBSb290ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSBmb3IgeW91ciBhcHBsaWNhdGlvbiAoaS5lLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7Q29tcGlsZXJCYXNlfSBmYWxsYmFja0NvbXBpbGVyIChvcHRpb25hbCkgIFdoZW4gYSBmaWxlIGlzIGNvbXBpbGVkXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIG1hdGNoaW5nIGNvbXBpbGVyLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGNvbXBpbGVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBJZlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCB3aWxsIGZhaWwgY29tcGlsYXRpb24uIEEgZ29vZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGUgZmFsbGJhY2sgaXMgdGhlIGNvbXBpbGVyIGZvclxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dC9wbGFpbicsIHdoaWNoIGlzIGd1YXJhbnRlZWQgdG8gYmVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8Q29tcGlsZXJIb3N0Pn0gIEEgcmVhZC1vbmx5IENvbXBpbGVySG9zdFxyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVSZWFkb25seUZyb21Db25maWd1cmF0aW9uKHJvb3RDYWNoZURpciwgYXBwUm9vdCwgZmFsbGJhY2tDb21waWxlcj1udWxsKSB7XHJcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xyXG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHBmcy5yZWFkRmlsZSh0YXJnZXQpO1xyXG4gICAgbGV0IGluZm8gPSBKU09OLnBhcnNlKGF3YWl0IHB6bGliLmd1bnppcChidWYpKTtcclxuXHJcbiAgICBsZXQgZmlsZUNoYW5nZUNhY2hlID0gRmlsZUNoYW5nZWRDYWNoZS5sb2FkRnJvbURhdGEoaW5mby5maWxlQ2hhbmdlQ2FjaGUsIGFwcFJvb3QsIHRydWUpO1xyXG5cclxuICAgIGxldCBjb21waWxlcnMgPSBPYmplY3Qua2V5cyhpbmZvLmNvbXBpbGVycykucmVkdWNlKChhY2MsIHgpID0+IHtcclxuICAgICAgbGV0IGN1ciA9IGluZm8uY29tcGlsZXJzW3hdO1xyXG4gICAgICBhY2NbeF0gPSBuZXcgUmVhZE9ubHlDb21waWxlcihjdXIubmFtZSwgY3VyLmNvbXBpbGVyVmVyc2lvbiwgY3VyLmNvbXBpbGVyT3B0aW9ucywgY3VyLmlucHV0TWltZVR5cGVzKTtcclxuXHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCB7fSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnMsIGZpbGVDaGFuZ2VDYWNoZSwgdHJ1ZSwgZmFsbGJhY2tDb21waWxlcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgZGV2ZWxvcG1lbnQtbW9kZSBDb21waWxlckhvc3QgZnJvbSB0aGUgcHJldmlvdXNseSBzYXZlZFxyXG4gICAqIGNvbmZpZ3VyYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAgVGhlIHJvb3QgZGlyZWN0b3J5IHRvIHVzZSBmb3IgdGhlIGNhY2hlLiBUaGlzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlIG11c3QgaGF2ZSBjYWNoZSBpbmZvcm1hdGlvbiBzYXZlZCB2aWFcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIHNhdmVDb25maWd1cmF0aW9ufVxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhcHBSb290ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSBmb3IgeW91ciBhcHBsaWNhdGlvbiAoaS5lLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjb21waWxlcnNCeU1pbWVUeXBlICBhbiBPYmplY3Qgd2hvc2Uga2V5cyBhcmUgaW5wdXQgTUlNRVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXMgYW5kIHdob3NlIHZhbHVlcyBhcmUgaW5zdGFuY2VzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBDb21waWxlckJhc2UuIENyZWF0ZSB0aGlzIHZpYSB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBjcmVhdGVDb21waWxlcnN9IG1ldGhvZCBpblxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLXBhcnNlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0NvbXBpbGVyQmFzZX0gZmFsbGJhY2tDb21waWxlciAob3B0aW9uYWwpICBXaGVuIGEgZmlsZSBpcyBjb21waWxlZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBkb2Vzbid0IGhhdmUgYSBtYXRjaGluZyBjb21waWxlcixcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBjb21waWxlciB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gSWZcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgd2lsbCBmYWlsIGNvbXBpbGF0aW9uLiBBIGdvb2RcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRlIGZhbGxiYWNrIGlzIHRoZSBjb21waWxlciBmb3JcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQvcGxhaW4nLCB3aGljaCBpcyBndWFyYW50ZWVkIHRvIGJlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbXBpbGVySG9zdD59ICBBIHJlYWQtb25seSBDb21waWxlckhvc3RcclxuICAgKi9cclxuICBzdGF0aWMgYXN5bmMgY3JlYXRlRnJvbUNvbmZpZ3VyYXRpb24ocm9vdENhY2hlRGlyLCBhcHBSb290LCBjb21waWxlcnNCeU1pbWVUeXBlLCBmYWxsYmFja0NvbXBpbGVyPW51bGwpIHtcclxuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4ocm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XHJcbiAgICBsZXQgYnVmID0gYXdhaXQgcGZzLnJlYWRGaWxlKHRhcmdldCk7XHJcbiAgICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoYXdhaXQgcHpsaWIuZ3VuemlwKGJ1ZikpO1xyXG5cclxuICAgIGxldCBmaWxlQ2hhbmdlQ2FjaGUgPSBGaWxlQ2hhbmdlZENhY2hlLmxvYWRGcm9tRGF0YShpbmZvLmZpbGVDaGFuZ2VDYWNoZSwgYXBwUm9vdCwgZmFsc2UpO1xyXG5cclxuICAgIE9iamVjdC5rZXlzKGluZm8uY29tcGlsZXJzKS5mb3JFYWNoKCh4KSA9PiB7XHJcbiAgICAgIGxldCBjdXIgPSBpbmZvLmNvbXBpbGVyc1t4XTtcclxuICAgICAgY29tcGlsZXJzQnlNaW1lVHlwZVt4XS5jb21waWxlck9wdGlvbnMgPSBjdXIuY29tcGlsZXJPcHRpb25zO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnNCeU1pbWVUeXBlLCBmaWxlQ2hhbmdlQ2FjaGUsIGZhbHNlLCBmYWxsYmFja0NvbXBpbGVyKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBTYXZlcyB0aGUgY3VycmVudCBjb21waWxlciBjb25maWd1cmF0aW9uIHRvIGEgZmlsZSB0aGF0XHJcbiAgICoge0BsaW5rIGNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb259IGNhbiB1c2UgdG8gcmVjcmVhdGUgdGhlIGN1cnJlbnRcclxuICAgKiBjb21waWxlciBlbnZpcm9ubWVudFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX0gIENvbXBsZXRpb25cclxuICAgKi9cclxuICBhc3luYyBzYXZlQ29uZmlndXJhdGlvbigpIHtcclxuICAgIGxldCBzZXJpYWxpemVkQ29tcGlsZXJPcHRzID0gT2JqZWN0LmtleXModGhpcy5jb21waWxlcnNCeU1pbWVUeXBlKS5yZWR1Y2UoKGFjYywgeCkgPT4ge1xyXG4gICAgICBsZXQgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbeF07XHJcbiAgICAgIGxldCBLbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb21waWxlcikuY29uc3RydWN0b3I7XHJcblxyXG4gICAgICBsZXQgdmFsID0ge1xyXG4gICAgICAgIG5hbWU6IEtsYXNzLm5hbWUsXHJcbiAgICAgICAgaW5wdXRNaW1lVHlwZXM6IEtsYXNzLmdldElucHV0TWltZVR5cGVzKCksXHJcbiAgICAgICAgY29tcGlsZXJPcHRpb25zOiBjb21waWxlci5jb21waWxlck9wdGlvbnMsXHJcbiAgICAgICAgY29tcGlsZXJWZXJzaW9uOiBjb21waWxlci5nZXRDb21waWxlclZlcnNpb24oKVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgYWNjW3hdID0gdmFsO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwge30pO1xyXG5cclxuICAgIGxldCBpbmZvID0ge1xyXG4gICAgICBmaWxlQ2hhbmdlQ2FjaGU6IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldFNhdmVkRGF0YSgpLFxyXG4gICAgICBjb21waWxlcnM6IHNlcmlhbGl6ZWRDb21waWxlck9wdHNcclxuICAgIH07XHJcblxyXG4gICAgbGV0IHRhcmdldCA9IHBhdGguam9pbih0aGlzLnJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xyXG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHB6bGliLmd6aXAobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeShpbmZvKSkpO1xyXG4gICAgYXdhaXQgcGZzLndyaXRlRmlsZSh0YXJnZXQsIGJ1Zik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21waWxlcyBhIGZpbGUgYW5kIHJldHVybnMgdGhlIGNvbXBpbGVkIHJlc3VsdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZmlsZVBhdGggIFRoZSBwYXRoIHRvIHRoZSBmaWxlIHRvIGNvbXBpbGVcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8b2JqZWN0Pn0gIEFuIE9iamVjdCB3aXRoIHRoZSBjb21waWxlZCByZXN1bHRcclxuICAgKlxyXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBoYXNoSW5mbyAgVGhlIGhhc2ggaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBnZXRIYXNoRm9yUGF0aFxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2RlICBUaGUgc291cmNlIGNvZGUgaWYgdGhlIGZpbGUgd2FzIGEgdGV4dCBmaWxlXHJcbiAgICogQHByb3BlcnR5IHtCdWZmZXJ9IGJpbmFyeURhdGEgIFRoZSBmaWxlIGlmIGl0IHdhcyBhIGJpbmFyeSBmaWxlXHJcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IG1pbWVUeXBlICBUaGUgTUlNRSB0eXBlIHNhdmVkIGluIHRoZSBjYWNoZS5cclxuICAgKiBAcHJvcGVydHkge3N0cmluZ1tdfSBkZXBlbmRlbnRGaWxlcyAgVGhlIGRlcGVuZGVudCBmaWxlcyByZXR1cm5lZCBmcm9tXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGluZyB0aGUgZmlsZSwgaWYgYW55LlxyXG4gICAqL1xyXG4gIGNvbXBpbGUoZmlsZVBhdGgpIHtcclxuICAgIHJldHVybiAodGhpcy5yZWFkT25seU1vZGUgPyB0aGlzLmNvbXBpbGVSZWFkT25seShmaWxlUGF0aCkgOiB0aGlzLmZ1bGxDb21waWxlKGZpbGVQYXRoKSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyBjb21waWxhdGlvbiBpbiByZWFkLW9ubHkgbW9kZVxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBhc3luYyBjb21waWxlUmVhZE9ubHkoZmlsZVBhdGgpIHtcclxuICAgIC8vIFdlIGd1YXJhbnRlZSB0aGF0IG5vZGVfbW9kdWxlcyBhcmUgYWx3YXlzIHNoaXBwZWQgZGlyZWN0bHlcclxuICAgIGxldCB0eXBlID0gbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCk7XHJcbiAgICBpZiAoRmlsZUNoYW5nZWRDYWNoZS5pc0luTm9kZU1vZHVsZXMoZmlsZVBhdGgpKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbWltZVR5cGU6IHR5cGUgfHwgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxyXG4gICAgICAgIGNvZGU6IGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0ZjgnKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBoYXNoSW5mbyA9IGF3YWl0IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldEhhc2hGb3JQYXRoKGZpbGVQYXRoKTtcclxuXHJcbiAgICAvLyBOQjogSGVyZSwgd2UncmUgYmFzaWNhbGx5IG9ubHkgdXNpbmcgdGhlIGNvbXBpbGVyIGhlcmUgdG8gZmluZFxyXG4gICAgLy8gdGhlIGFwcHJvcHJpYXRlIENvbXBpbGVDYWNoZVxyXG4gICAgbGV0IGNvbXBpbGVyID0gQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKSA/XHJcbiAgICAgIHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIDpcclxuICAgICAgdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3R5cGUgfHwgJ19fbG9sbm90aGVyZSddO1xyXG5cclxuICAgIGlmICghY29tcGlsZXIpIHtcclxuICAgICAgY29tcGlsZXIgPSB0aGlzLmZhbGxiYWNrQ29tcGlsZXI7XHJcblxyXG4gICAgICBsZXQgeyBjb2RlLCBiaW5hcnlEYXRhLCBtaW1lVHlwZSB9ID0gYXdhaXQgY29tcGlsZXIuZ2V0KGZpbGVQYXRoKTtcclxuICAgICAgcmV0dXJuIHsgY29kZTogY29kZSB8fCBiaW5hcnlEYXRhLCBtaW1lVHlwZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjYWNoZSA9IHRoaXMuY2FjaGVzRm9yQ29tcGlsZXJzLmdldChjb21waWxlcik7XHJcbiAgICBsZXQge2NvZGUsIGJpbmFyeURhdGEsIG1pbWVUeXBlfSA9IGF3YWl0IGNhY2hlLmdldChmaWxlUGF0aCk7XHJcblxyXG4gICAgY29kZSA9IGNvZGUgfHwgYmluYXJ5RGF0YTtcclxuICAgIGlmICghY29kZSB8fCAhbWltZVR5cGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc2tlZCB0byBjb21waWxlICR7ZmlsZVBhdGh9IGluIHByb2R1Y3Rpb24sIGlzIHRoaXMgZmlsZSBub3QgcHJlY29tcGlsZWQ/YCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgY29kZSwgbWltZVR5cGUgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZXMgY29tcGlsYXRpb24gaW4gcmVhZC13cml0ZSBtb2RlXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGFzeW5jIGZ1bGxDb21waWxlKGZpbGVQYXRoKSB7XHJcbiAgICBkKGBDb21waWxpbmcgJHtmaWxlUGF0aH1gKTtcclxuXHJcbiAgICBsZXQgaGFzaEluZm8gPSBhd2FpdCB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRIYXNoRm9yUGF0aChmaWxlUGF0aCk7XHJcbiAgICBsZXQgdHlwZSA9IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpO1xyXG5cclxuICAgIGlmIChoYXNoSW5mby5pc0luTm9kZU1vZHVsZXMpIHtcclxuICAgICAgbGV0IGNvZGUgPSBoYXNoSW5mby5zb3VyY2VDb2RlIHx8IGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0ZjgnKTtcclxuICAgICAgY29kZSA9IGF3YWl0IENvbXBpbGVySG9zdC5maXhOb2RlTW9kdWxlc1NvdXJjZU1hcHBpbmcoY29kZSwgZmlsZVBhdGgsIHRoaXMuZmlsZUNoYW5nZUNhY2hlLmFwcFJvb3QpO1xyXG4gICAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZTogdHlwZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjb21waWxlciA9IENvbXBpbGVySG9zdC5zaG91bGRQYXNzdGhyb3VnaChoYXNoSW5mbykgP1xyXG4gICAgICB0aGlzLmdldFBhc3N0aHJvdWdoQ29tcGlsZXIoKSA6XHJcbiAgICAgIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVt0eXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcclxuXHJcbiAgICBpZiAoIWNvbXBpbGVyKSB7XHJcbiAgICAgIGQoYEZhbGxpbmcgYmFjayB0byBwYXNzdGhyb3VnaCBjb21waWxlciBmb3IgJHtmaWxlUGF0aH1gKTtcclxuICAgICAgY29tcGlsZXIgPSB0aGlzLmZhbGxiYWNrQ29tcGlsZXI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjb21waWxlcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IGZpbmQgYSBjb21waWxlciBmb3IgJHtmaWxlUGF0aH1gKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY2FjaGUgPSB0aGlzLmNhY2hlc0ZvckNvbXBpbGVycy5nZXQoY29tcGlsZXIpO1xyXG4gICAgcmV0dXJuIGF3YWl0IGNhY2hlLmdldE9yRmV0Y2goXHJcbiAgICAgIGZpbGVQYXRoLFxyXG4gICAgICAoZmlsZVBhdGgsIGhhc2hJbmZvKSA9PiB0aGlzLmNvbXBpbGVVbmNhY2hlZChmaWxlUGF0aCwgaGFzaEluZm8sIGNvbXBpbGVyKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGVzIGludm9raW5nIGNvbXBpbGVycyBpbmRlcGVuZGVudCBvZiBjYWNoaW5nXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGFzeW5jIGNvbXBpbGVVbmNhY2hlZChmaWxlUGF0aCwgaGFzaEluZm8sIGNvbXBpbGVyKSB7XHJcbiAgICBsZXQgaW5wdXRNaW1lVHlwZSA9IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpO1xyXG5cclxuICAgIGlmIChoYXNoSW5mby5pc0ZpbGVCaW5hcnkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBiaW5hcnlEYXRhOiBoYXNoSW5mby5iaW5hcnlEYXRhIHx8IGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlUGF0aCksXHJcbiAgICAgICAgbWltZVR5cGU6IGlucHV0TWltZVR5cGUsXHJcbiAgICAgICAgZGVwZW5kZW50RmlsZXM6IFtdXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGN0eCA9IHt9O1xyXG4gICAgbGV0IGNvZGUgPSBoYXNoSW5mby5zb3VyY2VDb2RlIHx8IGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0ZjgnKTtcclxuXHJcbiAgICBpZiAoIShhd2FpdCBjb21waWxlci5zaG91bGRDb21waWxlRmlsZShjb2RlLCBjdHgpKSkge1xyXG4gICAgICBkKGBDb21waWxlciByZXR1cm5lZCBmYWxzZSBmb3Igc2hvdWxkQ29tcGlsZUZpbGU6ICR7ZmlsZVBhdGh9YCk7XHJcbiAgICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlOiBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKSwgZGVwZW5kZW50RmlsZXM6IFtdIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGRlcGVuZGVudEZpbGVzID0gYXdhaXQgY29tcGlsZXIuZGV0ZXJtaW5lRGVwZW5kZW50RmlsZXMoY29kZSwgZmlsZVBhdGgsIGN0eCk7XHJcblxyXG4gICAgZChgVXNpbmcgY29tcGlsZXIgb3B0aW9uczogJHtKU09OLnN0cmluZ2lmeShjb21waWxlci5jb21waWxlck9wdGlvbnMpfWApO1xyXG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVyLmNvbXBpbGUoY29kZSwgZmlsZVBhdGgsIGN0eCk7XHJcblxyXG4gICAgbGV0IHNob3VsZElubGluZUh0bWxpZnkgPVxyXG4gICAgICBpbnB1dE1pbWVUeXBlICE9PSAndGV4dC9odG1sJyAmJlxyXG4gICAgICByZXN1bHQubWltZVR5cGUgPT09ICd0ZXh0L2h0bWwnO1xyXG5cclxuICAgIGxldCBpc1Bhc3N0aHJvdWdoID1cclxuICAgICAgcmVzdWx0Lm1pbWVUeXBlID09PSAndGV4dC9wbGFpbicgfHxcclxuICAgICAgIXJlc3VsdC5taW1lVHlwZSB8fFxyXG4gICAgICBDb21waWxlckhvc3Quc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pO1xyXG5cclxuICAgIGlmICgoZmluYWxGb3Jtc1tyZXN1bHQubWltZVR5cGVdICYmICFzaG91bGRJbmxpbmVIdG1saWZ5KSB8fCBpc1Bhc3N0aHJvdWdoKSB7XHJcbiAgICAgIC8vIEdvdCBzb21ldGhpbmcgd2UgY2FuIHVzZSBpbi1icm93c2VyLCBsZXQncyByZXR1cm4gaXRcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7ZGVwZW5kZW50RmlsZXN9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGQoYFJlY3Vyc2l2ZWx5IGNvbXBpbGluZyByZXN1bHQgb2YgJHtmaWxlUGF0aH0gd2l0aCBub24tZmluYWwgTUlNRSB0eXBlICR7cmVzdWx0Lm1pbWVUeXBlfSwgaW5wdXQgd2FzICR7aW5wdXRNaW1lVHlwZX1gKTtcclxuXHJcbiAgICAgIGhhc2hJbmZvID0gT2JqZWN0LmFzc2lnbih7IHNvdXJjZUNvZGU6IHJlc3VsdC5jb2RlLCBtaW1lVHlwZTogcmVzdWx0Lm1pbWVUeXBlIH0sIGhhc2hJbmZvKTtcclxuICAgICAgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbcmVzdWx0Lm1pbWVUeXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcclxuXHJcbiAgICAgIGlmICghY29tcGlsZXIpIHtcclxuICAgICAgICBkKGBSZWN1cnNpdmUgY29tcGlsZSBmYWlsZWQgLSBpbnRlcm1lZGlhdGUgcmVzdWx0OiAke0pTT04uc3RyaW5naWZ5KHJlc3VsdCl9YCk7XHJcblxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcGlsaW5nICR7ZmlsZVBhdGh9IHJlc3VsdGVkIGluIGEgTUlNRSB0eXBlIG9mICR7cmVzdWx0Lm1pbWVUeXBlfSwgd2hpY2ggd2UgZG9uJ3Qga25vdyBob3cgdG8gaGFuZGxlYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbXBpbGVVbmNhY2hlZChcclxuICAgICAgICBgJHtmaWxlUGF0aH0uJHttaW1lVHlwZXMuZXh0ZW5zaW9uKHJlc3VsdC5taW1lVHlwZSB8fCAndHh0Jyl9YCxcclxuICAgICAgICBoYXNoSW5mbywgY29tcGlsZXIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJlLWNhY2hlcyBhbiBlbnRpcmUgZGlyZWN0b3J5IG9mIGZpbGVzIHJlY3Vyc2l2ZWx5LiBVc3VhbGx5IHVzZWQgZm9yXHJcbiAgICogYnVpbGRpbmcgY3VzdG9tIGNvbXBpbGVyIHRvb2xpbmcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3REaXJlY3RvcnkgIFRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IHRvIGNvbXBpbGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBzaG91bGRDb21waWxlIChvcHRpb25hbCkgIEEgRnVuY3Rpb24gd2hpY2ggYWxsb3dzIHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlciB0byBkaXNhYmxlIGNvbXBpbGluZyBjZXJ0YWluIGZpbGVzLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEl0IHRha2VzIGEgZnVsbHktcXVhbGlmaWVkIHBhdGggdG8gYSBmaWxlLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBzaG91bGQgcmV0dXJuIGEgQm9vbGVhbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9ICBDb21wbGV0aW9uLlxyXG4gICAqL1xyXG4gIGFzeW5jIGNvbXBpbGVBbGwocm9vdERpcmVjdG9yeSwgc2hvdWxkQ29tcGlsZT1udWxsKSB7XHJcbiAgICBsZXQgc2hvdWxkID0gc2hvdWxkQ29tcGlsZSB8fCBmdW5jdGlvbigpIHtyZXR1cm4gdHJ1ZTt9O1xyXG5cclxuICAgIGF3YWl0IGZvckFsbEZpbGVzKHJvb3REaXJlY3RvcnksIChmKSA9PiB7XHJcbiAgICAgIGlmICghc2hvdWxkKGYpKSByZXR1cm47XHJcblxyXG4gICAgICBkKGBDb21waWxpbmcgJHtmfWApO1xyXG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlKGYsIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgICogU3luYyBNZXRob2RzXHJcbiAgICovXHJcblxyXG4gIGNvbXBpbGVTeW5jKGZpbGVQYXRoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMucmVhZE9ubHlNb2RlID8gdGhpcy5jb21waWxlUmVhZE9ubHlTeW5jKGZpbGVQYXRoKSA6IHRoaXMuZnVsbENvbXBpbGVTeW5jKGZpbGVQYXRoKSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvblN5bmMocm9vdENhY2hlRGlyLCBhcHBSb290LCBmYWxsYmFja0NvbXBpbGVyPW51bGwpIHtcclxuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4ocm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XHJcbiAgICBsZXQgYnVmID0gZnMucmVhZEZpbGVTeW5jKHRhcmdldCk7XHJcbiAgICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoemxpYi5ndW56aXBTeW5jKGJ1ZikpO1xyXG5cclxuICAgIGxldCBmaWxlQ2hhbmdlQ2FjaGUgPSBGaWxlQ2hhbmdlZENhY2hlLmxvYWRGcm9tRGF0YShpbmZvLmZpbGVDaGFuZ2VDYWNoZSwgYXBwUm9vdCwgdHJ1ZSk7XHJcblxyXG4gICAgbGV0IGNvbXBpbGVycyA9IE9iamVjdC5rZXlzKGluZm8uY29tcGlsZXJzKS5yZWR1Y2UoKGFjYywgeCkgPT4ge1xyXG4gICAgICBsZXQgY3VyID0gaW5mby5jb21waWxlcnNbeF07XHJcbiAgICAgIGFjY1t4XSA9IG5ldyBSZWFkT25seUNvbXBpbGVyKGN1ci5uYW1lLCBjdXIuY29tcGlsZXJWZXJzaW9uLCBjdXIuY29tcGlsZXJPcHRpb25zLCBjdXIuaW5wdXRNaW1lVHlwZXMpO1xyXG5cclxuICAgICAgcmV0dXJuIGFjYztcclxuICAgIH0sIHt9KTtcclxuXHJcbiAgICByZXR1cm4gbmV3IENvbXBpbGVySG9zdChyb290Q2FjaGVEaXIsIGNvbXBpbGVycywgZmlsZUNoYW5nZUNhY2hlLCB0cnVlLCBmYWxsYmFja0NvbXBpbGVyKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjcmVhdGVGcm9tQ29uZmlndXJhdGlvblN5bmMocm9vdENhY2hlRGlyLCBhcHBSb290LCBjb21waWxlcnNCeU1pbWVUeXBlLCBmYWxsYmFja0NvbXBpbGVyPW51bGwpIHtcclxuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4ocm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XHJcbiAgICBsZXQgYnVmID0gZnMucmVhZEZpbGVTeW5jKHRhcmdldCk7XHJcbiAgICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoemxpYi5ndW56aXBTeW5jKGJ1ZikpO1xyXG5cclxuICAgIGxldCBmaWxlQ2hhbmdlQ2FjaGUgPSBGaWxlQ2hhbmdlZENhY2hlLmxvYWRGcm9tRGF0YShpbmZvLmZpbGVDaGFuZ2VDYWNoZSwgYXBwUm9vdCwgZmFsc2UpO1xyXG5cclxuICAgIE9iamVjdC5rZXlzKGluZm8uY29tcGlsZXJzKS5mb3JFYWNoKCh4KSA9PiB7XHJcbiAgICAgIGxldCBjdXIgPSBpbmZvLmNvbXBpbGVyc1t4XTtcclxuICAgICAgY29tcGlsZXJzQnlNaW1lVHlwZVt4XS5jb21waWxlck9wdGlvbnMgPSBjdXIuY29tcGlsZXJPcHRpb25zO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnNCeU1pbWVUeXBlLCBmaWxlQ2hhbmdlQ2FjaGUsIGZhbHNlLCBmYWxsYmFja0NvbXBpbGVyKTtcclxuICB9XHJcblxyXG4gIHNhdmVDb25maWd1cmF0aW9uU3luYygpIHtcclxuICAgIGxldCBzZXJpYWxpemVkQ29tcGlsZXJPcHRzID0gT2JqZWN0LmtleXModGhpcy5jb21waWxlcnNCeU1pbWVUeXBlKS5yZWR1Y2UoKGFjYywgeCkgPT4ge1xyXG4gICAgICBsZXQgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbeF07XHJcbiAgICAgIGxldCBLbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb21waWxlcikuY29uc3RydWN0b3I7XHJcblxyXG4gICAgICBsZXQgdmFsID0ge1xyXG4gICAgICAgIG5hbWU6IEtsYXNzLm5hbWUsXHJcbiAgICAgICAgaW5wdXRNaW1lVHlwZXM6IEtsYXNzLmdldElucHV0TWltZVR5cGVzKCksXHJcbiAgICAgICAgY29tcGlsZXJPcHRpb25zOiBjb21waWxlci5jb21waWxlck9wdGlvbnMsXHJcbiAgICAgICAgY29tcGlsZXJWZXJzaW9uOiBjb21waWxlci5nZXRDb21waWxlclZlcnNpb24oKVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgYWNjW3hdID0gdmFsO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwge30pO1xyXG5cclxuICAgIGxldCBpbmZvID0ge1xyXG4gICAgICBmaWxlQ2hhbmdlQ2FjaGU6IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldFNhdmVkRGF0YSgpLFxyXG4gICAgICBjb21waWxlcnM6IHNlcmlhbGl6ZWRDb21waWxlck9wdHNcclxuICAgIH07XHJcblxyXG4gICAgbGV0IHRhcmdldCA9IHBhdGguam9pbih0aGlzLnJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xyXG4gICAgbGV0IGJ1ZiA9IHpsaWIuZ3ppcFN5bmMobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeShpbmZvKSkpO1xyXG4gICAgZnMud3JpdGVGaWxlU3luYyh0YXJnZXQsIGJ1Zik7XHJcbiAgfVxyXG5cclxuICBjb21waWxlUmVhZE9ubHlTeW5jKGZpbGVQYXRoKSB7XHJcbiAgICAvLyBXZSBndWFyYW50ZWUgdGhhdCBub2RlX21vZHVsZXMgYXJlIGFsd2F5cyBzaGlwcGVkIGRpcmVjdGx5XHJcbiAgICBsZXQgdHlwZSA9IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpO1xyXG4gICAgaWYgKEZpbGVDaGFuZ2VkQ2FjaGUuaXNJbk5vZGVNb2R1bGVzKGZpbGVQYXRoKSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG1pbWVUeXBlOiB0eXBlIHx8ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyxcclxuICAgICAgICBjb2RlOiBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4JylcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgaGFzaEluZm8gPSB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRIYXNoRm9yUGF0aFN5bmMoZmlsZVBhdGgpO1xyXG5cclxuICAgIC8vIFdlIGd1YXJhbnRlZSB0aGF0IG5vZGVfbW9kdWxlcyBhcmUgYWx3YXlzIHNoaXBwZWQgZGlyZWN0bHlcclxuICAgIGlmIChoYXNoSW5mby5pc0luTm9kZU1vZHVsZXMpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBtaW1lVHlwZTogdHlwZSxcclxuICAgICAgICBjb2RlOiBoYXNoSW5mby5zb3VyY2VDb2RlIHx8IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5COiBIZXJlLCB3ZSdyZSBiYXNpY2FsbHkgb25seSB1c2luZyB0aGUgY29tcGlsZXIgaGVyZSB0byBmaW5kXHJcbiAgICAvLyB0aGUgYXBwcm9wcmlhdGUgQ29tcGlsZUNhY2hlXHJcbiAgICBsZXQgY29tcGlsZXIgPSBDb21waWxlckhvc3Quc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pID9cclxuICAgICAgdGhpcy5nZXRQYXNzdGhyb3VnaENvbXBpbGVyKCkgOlxyXG4gICAgICB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbdHlwZSB8fCAnX19sb2xub3RoZXJlJ107XHJcblxyXG4gICAgaWYgKCFjb21waWxlcikge1xyXG4gICAgICBjb21waWxlciA9IHRoaXMuZmFsbGJhY2tDb21waWxlcjtcclxuXHJcbiAgICAgIGxldCB7IGNvZGUsIGJpbmFyeURhdGEsIG1pbWVUeXBlIH0gPSBjb21waWxlci5nZXRTeW5jKGZpbGVQYXRoKTtcclxuICAgICAgcmV0dXJuIHsgY29kZTogY29kZSB8fCBiaW5hcnlEYXRhLCBtaW1lVHlwZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjYWNoZSA9IHRoaXMuY2FjaGVzRm9yQ29tcGlsZXJzLmdldChjb21waWxlcik7XHJcbiAgICBsZXQge2NvZGUsIGJpbmFyeURhdGEsIG1pbWVUeXBlfSA9IGNhY2hlLmdldFN5bmMoZmlsZVBhdGgpO1xyXG5cclxuICAgIGNvZGUgPSBjb2RlIHx8IGJpbmFyeURhdGE7XHJcbiAgICBpZiAoIWNvZGUgfHwgIW1pbWVUeXBlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXNrZWQgdG8gY29tcGlsZSAke2ZpbGVQYXRofSBpbiBwcm9kdWN0aW9uLCBpcyB0aGlzIGZpbGUgbm90IHByZWNvbXBpbGVkP2ApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlIH07XHJcbiAgfVxyXG5cclxuICBmdWxsQ29tcGlsZVN5bmMoZmlsZVBhdGgpIHtcclxuICAgIGQoYENvbXBpbGluZyAke2ZpbGVQYXRofWApO1xyXG5cclxuICAgIGxldCBoYXNoSW5mbyA9IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldEhhc2hGb3JQYXRoU3luYyhmaWxlUGF0aCk7XHJcbiAgICBsZXQgdHlwZSA9IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpO1xyXG5cclxuICAgIGlmIChoYXNoSW5mby5pc0luTm9kZU1vZHVsZXMpIHtcclxuICAgICAgbGV0IGNvZGUgPSBoYXNoSW5mby5zb3VyY2VDb2RlIHx8IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKTtcclxuICAgICAgY29kZSA9IENvbXBpbGVySG9zdC5maXhOb2RlTW9kdWxlc1NvdXJjZU1hcHBpbmdTeW5jKGNvZGUsIGZpbGVQYXRoLCB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5hcHBSb290KTtcclxuICAgICAgcmV0dXJuIHsgY29kZSwgbWltZVR5cGU6IHR5cGUgfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY29tcGlsZXIgPSBDb21waWxlckhvc3Quc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pID9cclxuICAgICAgdGhpcy5nZXRQYXNzdGhyb3VnaENvbXBpbGVyKCkgOlxyXG4gICAgICB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbdHlwZSB8fCAnX19sb2xub3RoZXJlJ107XHJcblxyXG4gICAgaWYgKCFjb21waWxlcikge1xyXG4gICAgICBkKGBGYWxsaW5nIGJhY2sgdG8gcGFzc3Rocm91Z2ggY29tcGlsZXIgZm9yICR7ZmlsZVBhdGh9YCk7XHJcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5mYWxsYmFja0NvbXBpbGVyO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY29tcGlsZXIpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZG4ndCBmaW5kIGEgY29tcGlsZXIgZm9yICR7ZmlsZVBhdGh9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNhY2hlID0gdGhpcy5jYWNoZXNGb3JDb21waWxlcnMuZ2V0KGNvbXBpbGVyKTtcclxuICAgIHJldHVybiBjYWNoZS5nZXRPckZldGNoU3luYyhcclxuICAgICAgZmlsZVBhdGgsXHJcbiAgICAgIChmaWxlUGF0aCwgaGFzaEluZm8pID0+IHRoaXMuY29tcGlsZVVuY2FjaGVkU3luYyhmaWxlUGF0aCwgaGFzaEluZm8sIGNvbXBpbGVyKSk7XHJcbiAgfVxyXG5cclxuICBjb21waWxlVW5jYWNoZWRTeW5jKGZpbGVQYXRoLCBoYXNoSW5mbywgY29tcGlsZXIpIHtcclxuICAgIGxldCBpbnB1dE1pbWVUeXBlID0gbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCk7XHJcblxyXG4gICAgaWYgKGhhc2hJbmZvLmlzRmlsZUJpbmFyeSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGJpbmFyeURhdGE6IGhhc2hJbmZvLmJpbmFyeURhdGEgfHwgZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoKSxcclxuICAgICAgICBtaW1lVHlwZTogaW5wdXRNaW1lVHlwZSxcclxuICAgICAgICBkZXBlbmRlbnRGaWxlczogW11cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY3R4ID0ge307XHJcbiAgICBsZXQgY29kZSA9IGhhc2hJbmZvLnNvdXJjZUNvZGUgfHwgZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpO1xyXG5cclxuICAgIGlmICghKGNvbXBpbGVyLnNob3VsZENvbXBpbGVGaWxlU3luYyhjb2RlLCBjdHgpKSkge1xyXG4gICAgICBkKGBDb21waWxlciByZXR1cm5lZCBmYWxzZSBmb3Igc2hvdWxkQ29tcGlsZUZpbGU6ICR7ZmlsZVBhdGh9YCk7XHJcbiAgICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlOiBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKSwgZGVwZW5kZW50RmlsZXM6IFtdIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGRlcGVuZGVudEZpbGVzID0gY29tcGlsZXIuZGV0ZXJtaW5lRGVwZW5kZW50RmlsZXNTeW5jKGNvZGUsIGZpbGVQYXRoLCBjdHgpO1xyXG5cclxuICAgIGxldCByZXN1bHQgPSBjb21waWxlci5jb21waWxlU3luYyhjb2RlLCBmaWxlUGF0aCwgY3R4KTtcclxuXHJcbiAgICBsZXQgc2hvdWxkSW5saW5lSHRtbGlmeSA9XHJcbiAgICAgIGlucHV0TWltZVR5cGUgIT09ICd0ZXh0L2h0bWwnICYmXHJcbiAgICAgIHJlc3VsdC5taW1lVHlwZSA9PT0gJ3RleHQvaHRtbCc7XHJcblxyXG4gICAgbGV0IGlzUGFzc3Rocm91Z2ggPVxyXG4gICAgICByZXN1bHQubWltZVR5cGUgPT09ICd0ZXh0L3BsYWluJyB8fFxyXG4gICAgICAhcmVzdWx0Lm1pbWVUeXBlIHx8XHJcbiAgICAgIENvbXBpbGVySG9zdC5zaG91bGRQYXNzdGhyb3VnaChoYXNoSW5mbyk7XHJcblxyXG4gICAgaWYgKChmaW5hbEZvcm1zW3Jlc3VsdC5taW1lVHlwZV0gJiYgIXNob3VsZElubGluZUh0bWxpZnkpIHx8IGlzUGFzc3Rocm91Z2gpIHtcclxuICAgICAgLy8gR290IHNvbWV0aGluZyB3ZSBjYW4gdXNlIGluLWJyb3dzZXIsIGxldCdzIHJldHVybiBpdFxyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHtkZXBlbmRlbnRGaWxlc30pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZChgUmVjdXJzaXZlbHkgY29tcGlsaW5nIHJlc3VsdCBvZiAke2ZpbGVQYXRofSB3aXRoIG5vbi1maW5hbCBNSU1FIHR5cGUgJHtyZXN1bHQubWltZVR5cGV9LCBpbnB1dCB3YXMgJHtpbnB1dE1pbWVUeXBlfWApO1xyXG5cclxuICAgICAgaGFzaEluZm8gPSBPYmplY3QuYXNzaWduKHsgc291cmNlQ29kZTogcmVzdWx0LmNvZGUsIG1pbWVUeXBlOiByZXN1bHQubWltZVR5cGUgfSwgaGFzaEluZm8pO1xyXG4gICAgICBjb21waWxlciA9IHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVtyZXN1bHQubWltZVR5cGUgfHwgJ19fbG9sbm90aGVyZSddO1xyXG5cclxuICAgICAgaWYgKCFjb21waWxlcikge1xyXG4gICAgICAgIGQoYFJlY3Vyc2l2ZSBjb21waWxlIGZhaWxlZCAtIGludGVybWVkaWF0ZSByZXN1bHQ6ICR7SlNPTi5zdHJpbmdpZnkocmVzdWx0KX1gKTtcclxuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21waWxpbmcgJHtmaWxlUGF0aH0gcmVzdWx0ZWQgaW4gYSBNSU1FIHR5cGUgb2YgJHtyZXN1bHQubWltZVR5cGV9LCB3aGljaCB3ZSBkb24ndCBrbm93IGhvdyB0byBoYW5kbGVgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZVVuY2FjaGVkU3luYyhcclxuICAgICAgICBgJHtmaWxlUGF0aH0uJHttaW1lVHlwZXMuZXh0ZW5zaW9uKHJlc3VsdC5taW1lVHlwZSB8fCAndHh0Jyl9YCxcclxuICAgICAgICBoYXNoSW5mbywgY29tcGlsZXIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29tcGlsZUFsbFN5bmMocm9vdERpcmVjdG9yeSwgc2hvdWxkQ29tcGlsZT1udWxsKSB7XHJcbiAgICBsZXQgc2hvdWxkID0gc2hvdWxkQ29tcGlsZSB8fCBmdW5jdGlvbigpIHtyZXR1cm4gdHJ1ZTt9O1xyXG5cclxuICAgIGZvckFsbEZpbGVzU3luYyhyb290RGlyZWN0b3J5LCAoZikgPT4ge1xyXG4gICAgICBpZiAoIXNob3VsZChmKSkgcmV0dXJuO1xyXG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlU3luYyhmLCB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAqIE90aGVyIHN0dWZmXHJcbiAgICovXHJcblxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBwYXNzdGhyb3VnaCBjb21waWxlclxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBnZXRQYXNzdGhyb3VnaENvbXBpbGVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVsndGV4dC9wbGFpbiddO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgd2hldGhlciB3ZSBzaG91bGQgZXZlbiB0cnkgdG8gY29tcGlsZSB0aGUgY29udGVudC4gTm90ZSB0aGF0IGluXHJcbiAgICogc29tZSBjYXNlcywgY29udGVudCB3aWxsIHN0aWxsIGJlIGluIGNhY2hlIGV2ZW4gaWYgdGhpcyByZXR1cm5zIHRydWUsIGFuZFxyXG4gICAqIGluIG90aGVyIGNhc2VzIChpc0luTm9kZU1vZHVsZXMpLCB3ZSdsbCBrbm93IGV4cGxpY2l0bHkgdG8gbm90IGV2ZW4gYm90aGVyXHJcbiAgICogbG9va2luZyBpbiB0aGUgY2FjaGUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBzaG91bGRQYXNzdGhyb3VnaChoYXNoSW5mbykge1xyXG4gICAgcmV0dXJuIGhhc2hJbmZvLmlzTWluaWZpZWQgfHwgaGFzaEluZm8uaXNJbk5vZGVNb2R1bGVzIHx8IGhhc2hJbmZvLmhhc1NvdXJjZU1hcCB8fCBoYXNoSW5mby5pc0ZpbGVCaW5hcnk7XHJcbiAgfVxyXG4gICAgXHJcbiAgLyoqXHJcbiAgICogTG9vayBhdCB0aGUgY29kZSBvZiBhIG5vZGUgbW9kdWxlcyBhbmQgc2VlIHRoZSBzb3VyY2VNYXBwaW5nIHBhdGguXHJcbiAgICogSWYgdGhlcmUgaXMgYW55LCBjaGVjayB0aGUgcGF0aCBhbmQgdHJ5IHRvIGZpeCBpdCB3aXRoIGFuZFxyXG4gICAqIHJvb3QgcmVsYXRpdmUgcGF0aC5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBmaXhOb2RlTW9kdWxlc1NvdXJjZU1hcHBpbmcoc291cmNlQ29kZSwgc291cmNlUGF0aCwgYXBwUm9vdCkge1xyXG4gICAgbGV0IHJlZ2V4U291cmNlTWFwcGluZyA9IC9cXC9cXC8jLipzb3VyY2VNYXBwaW5nVVJMPSg/IWRhdGE6KShbXlwiJ10uKikvaTtcclxuICAgIGxldCBzb3VyY2VNYXBwaW5nQ2hlY2sgPSBzb3VyY2VDb2RlLm1hdGNoKHJlZ2V4U291cmNlTWFwcGluZyk7XHJcblxyXG4gICAgaWYgKHNvdXJjZU1hcHBpbmdDaGVjayAmJiBzb3VyY2VNYXBwaW5nQ2hlY2tbMV0gJiYgc291cmNlTWFwcGluZ0NoZWNrWzFdICE9PSAnJyl7XHJcbiAgICAgIGxldCBzb3VyY2VNYXBQYXRoID0gc291cmNlTWFwcGluZ0NoZWNrWzFdO1xyXG4gICAgICBcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBwZnMuc3RhdChzb3VyY2VNYXBQYXRoKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBsZXQgbm9ybVJvb3QgPSBwYXRoLm5vcm1hbGl6ZShhcHBSb290KTtcclxuICAgICAgICBsZXQgYWJzUGF0aFRvTW9kdWxlID0gcGF0aC5kaXJuYW1lKHNvdXJjZVBhdGgucmVwbGFjZShub3JtUm9vdCwgJycpLnN1YnN0cmluZygxKSk7XHJcbiAgICAgICAgbGV0IG5ld01hcFBhdGggPSBwYXRoLmpvaW4oYWJzUGF0aFRvTW9kdWxlLCBzb3VyY2VNYXBQYXRoKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gc291cmNlQ29kZS5yZXBsYWNlKHJlZ2V4U291cmNlTWFwcGluZywgYC8vIyBzb3VyY2VNYXBwaW5nVVJMPSR7bmV3TWFwUGF0aH1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gc291cmNlQ29kZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvb2sgYXQgdGhlIGNvZGUgb2YgYSBub2RlIG1vZHVsZXMgYW5kIHNlZSB0aGUgc291cmNlTWFwcGluZyBwYXRoLlxyXG4gICAqIElmIHRoZXJlIGlzIGFueSwgY2hlY2sgdGhlIHBhdGggYW5kIHRyeSB0byBmaXggaXQgd2l0aCBhbmRcclxuICAgKiByb290IHJlbGF0aXZlIHBhdGguXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgZml4Tm9kZU1vZHVsZXNTb3VyY2VNYXBwaW5nU3luYyhzb3VyY2VDb2RlLCBzb3VyY2VQYXRoLCBhcHBSb290KSB7XHJcbiAgICBsZXQgcmVnZXhTb3VyY2VNYXBwaW5nID0gL1xcL1xcLyMuKnNvdXJjZU1hcHBpbmdVUkw9KD8hZGF0YTopKFteXCInXS4qKS9pO1xyXG4gICAgbGV0IHNvdXJjZU1hcHBpbmdDaGVjayA9IHNvdXJjZUNvZGUubWF0Y2gocmVnZXhTb3VyY2VNYXBwaW5nKTtcclxuXHJcbiAgICBpZiAoc291cmNlTWFwcGluZ0NoZWNrICYmIHNvdXJjZU1hcHBpbmdDaGVja1sxXSAmJiBzb3VyY2VNYXBwaW5nQ2hlY2tbMV0gIT09ICcnKXtcclxuICAgICAgbGV0IHNvdXJjZU1hcFBhdGggPSBzb3VyY2VNYXBwaW5nQ2hlY2tbMV07XHJcbiAgICAgIFxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGZzLnN0YXRTeW5jKHNvdXJjZU1hcFBhdGgpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGxldCBub3JtUm9vdCA9IHBhdGgubm9ybWFsaXplKGFwcFJvb3QpO1xyXG4gICAgICAgIGxldCBhYnNQYXRoVG9Nb2R1bGUgPSBwYXRoLmRpcm5hbWUoc291cmNlUGF0aC5yZXBsYWNlKG5vcm1Sb290LCAnJykuc3Vic3RyaW5nKDEpKTtcclxuICAgICAgICBsZXQgbmV3TWFwUGF0aCA9IHBhdGguam9pbihhYnNQYXRoVG9Nb2R1bGUsIHNvdXJjZU1hcFBhdGgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBzb3VyY2VDb2RlLnJlcGxhY2UocmVnZXhTb3VyY2VNYXBwaW5nLCBgLy8jIHNvdXJjZU1hcHBpbmdVUkw9JHtuZXdNYXBQYXRofWApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBzb3VyY2VDb2RlO1xyXG4gIH1cclxufVxyXG4iXX0=