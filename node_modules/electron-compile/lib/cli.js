#!/usr/bin/env node
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.main = undefined;

let main = exports.main = (() => {
  var _ref = _asyncToGenerator(function* (appDir, sourceDirs, cacheDir) {
    let compilerHost = null;
    if (!cacheDir || cacheDir.length < 1) {
      cacheDir = '.cache';
    }

    let rootCacheDir = _path2.default.join(appDir, cacheDir);
    _mkdirp2.default.sync(rootCacheDir);

    if (process.env.NODE_ENV !== 'production') {
      console.log(`Using NODE_ENV = ${ process.env.NODE_ENV || 'development' }`);
    }

    d(`main: ${ appDir }, ${ JSON.stringify(sourceDirs) }`);
    try {
      compilerHost = yield (0, _configParser.createCompilerHostFromProjectRoot)(appDir, rootCacheDir);
    } catch (e) {
      console.error(`Couldn't set up compilers: ${ e.message }`);
      d(e.stack);

      throw e;
    }

    yield Promise.all(sourceDirs.map(function (dir) {
      return (0, _forAllFiles.forAllFiles)(dir, (() => {
        var _ref2 = _asyncToGenerator(function* (f) {
          try {
            d(`Starting compilation for ${ f }`);
            yield compilerHost.compile(f);
          } catch (e) {
            console.error(`Failed to compile file: ${ f }`);
            console.error(e.message);

            d(e.stack);
          }
        });

        return function (_x4) {
          return _ref2.apply(this, arguments);
        };
      })());
    }));

    d('Saving out configuration');
    yield compilerHost.saveConfiguration();
  });

  return function main(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
})();

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _configParser = require('./config-parser');

var _forAllFiles = require('./for-all-files');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

process.on('unhandledRejection', e => {
  d(e.message || e);
  d(e.stack || '');
});

process.on('uncaughtException', e => {
  d(e.message || e);
  d(e.stack || '');
});

const d = require('debug-electron')('electron-compile');

const yargs = require('yargs').usage('Usage: electron-compile --appdir [root-app-dir] paths...').alias('a', 'appdir').describe('a', 'The top-level application directory (i.e. where your package.json is)').default('a', process.cwd()).alias('c', 'cachedir').describe('c', 'The directory to put the cache').default('c', '.cache').help('h').alias('h', 'help').epilog('Copyright 2015');

if (process.mainModule === module) {
  const argv = yargs.argv;

  if (!argv._ || argv._.length < 1) {
    yargs.showHelp();
    process.exit(-1);
  }

  const sourceDirs = argv._;
  const appDir = argv.a;
  const cacheDir = argv.c;

  main(appDir, sourceDirs, cacheDir).then(() => process.exit(0)).catch(e => {
    console.error(e.message || e);
    d(e.stack);

    console.error("Compilation failed!\nFor extra information, set the DEBUG environment variable to '*'");
    process.exit(-1);
  });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jbGkuanMiXSwibmFtZXMiOlsiYXBwRGlyIiwic291cmNlRGlycyIsImNhY2hlRGlyIiwiY29tcGlsZXJIb3N0IiwibGVuZ3RoIiwicm9vdENhY2hlRGlyIiwiam9pbiIsInN5bmMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJjb25zb2xlIiwibG9nIiwiZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJlIiwiZXJyb3IiLCJtZXNzYWdlIiwic3RhY2siLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiZGlyIiwiZiIsImNvbXBpbGUiLCJzYXZlQ29uZmlndXJhdGlvbiIsIm1haW4iLCJvbiIsInJlcXVpcmUiLCJ5YXJncyIsInVzYWdlIiwiYWxpYXMiLCJkZXNjcmliZSIsImRlZmF1bHQiLCJjd2QiLCJoZWxwIiwiZXBpbG9nIiwibWFpbk1vZHVsZSIsIm1vZHVsZSIsImFyZ3YiLCJfIiwic2hvd0hlbHAiLCJleGl0IiwiYSIsImMiLCJ0aGVuIiwiY2F0Y2giXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OytCQWtCTyxXQUFvQkEsTUFBcEIsRUFBNEJDLFVBQTVCLEVBQXdDQyxRQUF4QyxFQUFrRDtBQUN2RCxRQUFJQyxlQUFlLElBQW5CO0FBQ0EsUUFBSSxDQUFDRCxRQUFELElBQWFBLFNBQVNFLE1BQVQsR0FBa0IsQ0FBbkMsRUFBc0M7QUFDcENGLGlCQUFXLFFBQVg7QUFDRDs7QUFFRCxRQUFJRyxlQUFlLGVBQUtDLElBQUwsQ0FBVU4sTUFBVixFQUFrQkUsUUFBbEIsQ0FBbkI7QUFDQSxxQkFBT0ssSUFBUCxDQUFZRixZQUFaOztBQUVBLFFBQUlHLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q0MsY0FBUUMsR0FBUixDQUFhLHFCQUFtQkosUUFBUUMsR0FBUixDQUFZQyxRQUFaLElBQXdCLGFBQWMsR0FBdEU7QUFDRDs7QUFFREcsTUFBRyxVQUFRYixNQUFPLE9BQUljLEtBQUtDLFNBQUwsQ0FBZWQsVUFBZixDQUEy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S0FBSjs7QUFFQVIsWUFBUU0sS0FBUixDQUFjLHVGQUFkO0FBQ0FULFlBQVFtQyxJQUFSLENBQWEsQ0FBQyxDQUFkO0FBQ0QsR0FSSDtBQVNEIiwiZmlsZSI6ImNsaS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG5cclxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCBta2RpcnAgZnJvbSAnbWtkaXJwJztcclxuXHJcbmltcG9ydCB7Y3JlYXRlQ29tcGlsZXJIb3N0RnJvbVByb2plY3RSb290fSBmcm9tICcuL2NvbmZpZy1wYXJzZXInO1xyXG5pbXBvcnQge2ZvckFsbEZpbGVzfSBmcm9tICcuL2Zvci1hbGwtZmlsZXMnO1xyXG5cclxucHJvY2Vzcy5vbigndW5oYW5kbGVkUmVqZWN0aW9uJywgKGUpID0+IHtcclxuICBkKGUubWVzc2FnZSB8fCBlKTtcclxuICBkKGUuc3RhY2sgfHwgJycpO1xyXG59KTtcclxuXHJcbnByb2Nlc3Mub24oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgKGUpID0+IHtcclxuICBkKGUubWVzc2FnZSB8fCBlKTtcclxuICBkKGUuc3RhY2sgfHwgJycpO1xyXG59KTtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtYWluKGFwcERpciwgc291cmNlRGlycywgY2FjaGVEaXIpIHtcclxuICBsZXQgY29tcGlsZXJIb3N0ID0gbnVsbDtcclxuICBpZiAoIWNhY2hlRGlyIHx8IGNhY2hlRGlyLmxlbmd0aCA8IDEpIHtcclxuICAgIGNhY2hlRGlyID0gJy5jYWNoZSc7XHJcbiAgfVxyXG5cclxuICBsZXQgcm9vdENhY2hlRGlyID0gcGF0aC5qb2luKGFwcERpciwgY2FjaGVEaXIpO1xyXG4gIG1rZGlycC5zeW5jKHJvb3RDYWNoZURpcik7XHJcblxyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBjb25zb2xlLmxvZyhgVXNpbmcgTk9ERV9FTlYgPSAke3Byb2Nlc3MuZW52Lk5PREVfRU5WIHx8ICdkZXZlbG9wbWVudCd9YCk7XHJcbiAgfVxyXG5cclxuICBkKGBtYWluOiAke2FwcERpcn0sICR7SlNPTi5zdHJpbmdpZnkoc291cmNlRGlycyl9YCk7XHJcbiAgdHJ5IHtcclxuICAgIGNvbXBpbGVySG9zdCA9IGF3YWl0IGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Qcm9qZWN0Um9vdChhcHBEaXIsIHJvb3RDYWNoZURpcik7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS5lcnJvcihgQ291bGRuJ3Qgc2V0IHVwIGNvbXBpbGVyczogJHtlLm1lc3NhZ2V9YCk7XHJcbiAgICBkKGUuc3RhY2spO1xyXG5cclxuICAgIHRocm93IGU7XHJcbiAgfVxyXG5cclxuICBhd2FpdCBQcm9taXNlLmFsbChzb3VyY2VEaXJzLm1hcCgoZGlyKSA9PiBmb3JBbGxGaWxlcyhkaXIsIGFzeW5jIChmKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBkKGBTdGFydGluZyBjb21waWxhdGlvbiBmb3IgJHtmfWApO1xyXG4gICAgICBhd2FpdCBjb21waWxlckhvc3QuY29tcGlsZShmKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGNvbXBpbGUgZmlsZTogJHtmfWApO1xyXG4gICAgICBjb25zb2xlLmVycm9yKGUubWVzc2FnZSk7XHJcblxyXG4gICAgICBkKGUuc3RhY2spO1xyXG4gICAgfVxyXG4gIH0pKSk7XHJcblxyXG4gIGQoJ1NhdmluZyBvdXQgY29uZmlndXJhdGlvbicpO1xyXG4gIGF3YWl0IGNvbXBpbGVySG9zdC5zYXZlQ29uZmlndXJhdGlvbigpO1xyXG59XHJcblxyXG5jb25zdCBkID0gcmVxdWlyZSgnZGVidWctZWxlY3Ryb24nKSgnZWxlY3Ryb24tY29tcGlsZScpO1xyXG5cclxuY29uc3QgeWFyZ3MgPSByZXF1aXJlKCd5YXJncycpXHJcbiAgLnVzYWdlKCdVc2FnZTogZWxlY3Ryb24tY29tcGlsZSAtLWFwcGRpciBbcm9vdC1hcHAtZGlyXSBwYXRocy4uLicpXHJcbiAgLmFsaWFzKCdhJywgJ2FwcGRpcicpXHJcbiAgLmRlc2NyaWJlKCdhJywgJ1RoZSB0b3AtbGV2ZWwgYXBwbGljYXRpb24gZGlyZWN0b3J5IChpLmUuIHdoZXJlIHlvdXIgcGFja2FnZS5qc29uIGlzKScpXHJcbiAgLmRlZmF1bHQoJ2EnLCBwcm9jZXNzLmN3ZCgpKVxyXG4gIC5hbGlhcygnYycsICdjYWNoZWRpcicpXHJcbiAgLmRlc2NyaWJlKCdjJywgJ1RoZSBkaXJlY3RvcnkgdG8gcHV0IHRoZSBjYWNoZScpXHJcbiAgLmRlZmF1bHQoJ2MnLCAnLmNhY2hlJylcclxuICAuaGVscCgnaCcpXHJcbiAgLmFsaWFzKCdoJywgJ2hlbHAnKVxyXG4gIC5lcGlsb2coJ0NvcHlyaWdodCAyMDE1Jyk7XHJcblxyXG5pZiAocHJvY2Vzcy5tYWluTW9kdWxlID09PSBtb2R1bGUpIHtcclxuICBjb25zdCBhcmd2ID0geWFyZ3MuYXJndjtcclxuXHJcbiAgaWYgKCFhcmd2Ll8gfHwgYXJndi5fLmxlbmd0aCA8IDEpIHtcclxuICAgIHlhcmdzLnNob3dIZWxwKCk7XHJcbiAgICBwcm9jZXNzLmV4aXQoLTEpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc291cmNlRGlycyA9IGFyZ3YuXztcclxuICBjb25zdCBhcHBEaXIgPSBhcmd2LmE7XHJcbiAgY29uc3QgY2FjaGVEaXIgPSBhcmd2LmM7XHJcblxyXG4gIG1haW4oYXBwRGlyLCBzb3VyY2VEaXJzLCBjYWNoZURpcilcclxuICAgIC50aGVuKCgpID0+IHByb2Nlc3MuZXhpdCgwKSlcclxuICAgIC5jYXRjaCgoZSkgPT4ge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGUubWVzc2FnZSB8fCBlKTtcclxuICAgICAgZChlLnN0YWNrKTtcclxuXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb21waWxhdGlvbiBmYWlsZWQhXFxuRm9yIGV4dHJhIGluZm9ybWF0aW9uLCBzZXQgdGhlIERFQlVHIGVudmlyb25tZW50IHZhcmlhYmxlIHRvICcqJ1wiKTtcclxuICAgICAgcHJvY2Vzcy5leGl0KC0xKTtcclxuICAgIH0pO1xyXG59XHJcbiJdfQ==