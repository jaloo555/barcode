'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sanitizeFilePath;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _lruCache = require('lru-cache');

var _lruCache2 = _interopRequireDefault(_lruCache);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = require('debug-electron')('electron-compile:sanitize-paths');
const realpathCache = (0, _lruCache2.default)({ max: 32 });

function cachedRealpath(p) {
  let ret = realpathCache.get(p);
  if (ret) return ret;

  ret = _fs2.default.realpathSync(p);
  d(`Cache miss for cachedRealpath: '${ p }' => '${ ret }'`);

  realpathCache.set(p, ret);
  return ret;
}

/**
 * Electron will sometimes hand us paths that don't match the platform if they
 * were derived from a URL (i.e. 'C:/Users/Paul/...'), whereas the cache will have
 * saved paths with backslashes.
 *
 * @private
 */
function sanitizeFilePath(file) {
  if (!file) return file;

  // NB: Some people add symlinks into system directories. node.js will internally
  // call realpath on paths that it finds, which will break our cache resolution.
  // We need to catch this scenario and fix it up. The tricky part is, some parts
  // of Electron will give us the pre-resolved paths, and others will give us the
  // post-resolved one. We need to handle both.

  let realFile = null;
  let parts = file.split(/[\\\/]app.asar[\\\/]/);
  if (!parts[1]) {
    // Not using an ASAR archive
    realFile = cachedRealpath(file);
  } else {
    // We do all this silliness to work around
    // https://github.com/atom/electron/issues/4610
    realFile = `${ cachedRealpath(parts[0]) }/app.asar/${ parts[1] }`;
  }

  return realFile.replace(/[\\\/]/g, '/');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zYW5pdGl6ZS1wYXRocy5qcyJdLCJuYW1lcyI6WyJzYW5pdGl6ZUZpbGVQYXRoIiwiZCIsInJlcXVpcmUiLCJyZWFscGF0aENhY2hlIiwibWF4IiwiY2FjaGVkUmVhbHBhdGgiLCJwIiwicmV0IiwiZ2V0IiwicmVhbHBhdGhTeW5jIiwic2V0IiwiZmlsZSIsInJlYWxGaWxlIiwicGFydHMiLCJzcGxpdCIsInJlcGxhY2UiXSwibWFwcGluZ3MiOiI7Ozs7O2tCQXdCd0JBLGdCOztBQXhCeEI7Ozs7QUFDQTs7Ozs7O0FBRUEsTUFBTUMsSUFBSUMsUUFBUSxnQkFBUixFQUEwQixpQ0FBMUIsQ0FBVjtBQUNBLE1BQU1DLGdCQUFnQix3QkFBUyxFQUFFQyxLQUFLLEVBQVAsRUFBVCxDQUF0Qjs7QUFFQSxTQUFTQyxjQUFULENBQXdCQyxDQUF4QixFQUEyQjtBQUN6QixNQUFJQyxNQUFNSixjQUFjSyxHQUFkLENBQWtCRixDQUFsQixDQUFWO0FBQ0EsTUFBSUMsR0FBSixFQUFTLE9BQU9BLEdBQVA7O0FBRVRBLFFBQU0sYUFBR0UsWUFBSCxDQUFnQkgsQ0FBaEIsQ0FBTjtBQUNBTCxJQUFHLG9DQUFrQ0ssQ0FBRSxXQUFRQyxHQUFJLElBQW5EOztBQUVBSixnQkFBY08sR0FBZCxDQUFrQkosQ0FBbEIsRUFBcUJDLEdBQXJCO0FBQ0EsU0FBT0EsR0FBUDtBQUNEOztBQUVEOzs7Ozs7O0FBT2UsU0FBU1AsZ0JBQVQsQ0FBMEJXLElBQTFCLEVBQWdDO0FBQzdDLE1BQUksQ0FBQ0EsSUFBTCxFQUFXLE9BQU9BLElBQVA7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFJQyxXQUFXLElBQWY7QUFDQSxNQUFJQyxRQUFRRixLQUFLRyxLQUFMLENBQVcsc0JBQVgsQ0FBWjtBQUNBLE1BQUksQ0FBQ0QsTUFBTSxDQUFOLENBQUwsRUFBZTtBQUNiO0FBQ0FELGVBQVdQLGVBQWVNLElBQWYsQ0FBWDtBQUNELEdBSEQsTUFHTztBQUNMO0FBQ0E7QUFDQUMsZUFBWSxJQUFFUCxlQUFlUSxNQUFNLENBQU4sQ0FBZixDQUF5QixlQUFZQSxNQUFNLENBQU4sQ0FBUyxHQUE1RDtBQUNEOztBQUVELFNBQU9ELFNBQVNHLE9BQVQsQ0FBaUIsU0FBakIsRUFBNEIsR0FBNUIsQ0FBUDtBQUNEIiwiZmlsZSI6InNhbml0aXplLXBhdGhzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IExSVUNhY2hlIGZyb20gJ2xydS1jYWNoZSc7XHJcblxyXG5jb25zdCBkID0gcmVxdWlyZSgnZGVidWctZWxlY3Ryb24nKSgnZWxlY3Ryb24tY29tcGlsZTpzYW5pdGl6ZS1wYXRocycpO1xyXG5jb25zdCByZWFscGF0aENhY2hlID0gTFJVQ2FjaGUoeyBtYXg6IDMyIH0pO1xyXG5cclxuZnVuY3Rpb24gY2FjaGVkUmVhbHBhdGgocCkge1xyXG4gIGxldCByZXQgPSByZWFscGF0aENhY2hlLmdldChwKTtcclxuICBpZiAocmV0KSByZXR1cm4gcmV0O1xyXG5cclxuICByZXQgPSBmcy5yZWFscGF0aFN5bmMocCk7XHJcbiAgZChgQ2FjaGUgbWlzcyBmb3IgY2FjaGVkUmVhbHBhdGg6ICcke3B9JyA9PiAnJHtyZXR9J2ApO1xyXG5cclxuICByZWFscGF0aENhY2hlLnNldChwLCByZXQpO1xyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbGVjdHJvbiB3aWxsIHNvbWV0aW1lcyBoYW5kIHVzIHBhdGhzIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIHBsYXRmb3JtIGlmIHRoZXlcclxuICogd2VyZSBkZXJpdmVkIGZyb20gYSBVUkwgKGkuZS4gJ0M6L1VzZXJzL1BhdWwvLi4uJyksIHdoZXJlYXMgdGhlIGNhY2hlIHdpbGwgaGF2ZVxyXG4gKiBzYXZlZCBwYXRocyB3aXRoIGJhY2tzbGFzaGVzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2FuaXRpemVGaWxlUGF0aChmaWxlKSB7XHJcbiAgaWYgKCFmaWxlKSByZXR1cm4gZmlsZTtcclxuXHJcbiAgLy8gTkI6IFNvbWUgcGVvcGxlIGFkZCBzeW1saW5rcyBpbnRvIHN5c3RlbSBkaXJlY3Rvcmllcy4gbm9kZS5qcyB3aWxsIGludGVybmFsbHlcclxuICAvLyBjYWxsIHJlYWxwYXRoIG9uIHBhdGhzIHRoYXQgaXQgZmluZHMsIHdoaWNoIHdpbGwgYnJlYWsgb3VyIGNhY2hlIHJlc29sdXRpb24uXHJcbiAgLy8gV2UgbmVlZCB0byBjYXRjaCB0aGlzIHNjZW5hcmlvIGFuZCBmaXggaXQgdXAuIFRoZSB0cmlja3kgcGFydCBpcywgc29tZSBwYXJ0c1xyXG4gIC8vIG9mIEVsZWN0cm9uIHdpbGwgZ2l2ZSB1cyB0aGUgcHJlLXJlc29sdmVkIHBhdGhzLCBhbmQgb3RoZXJzIHdpbGwgZ2l2ZSB1cyB0aGVcclxuICAvLyBwb3N0LXJlc29sdmVkIG9uZS4gV2UgbmVlZCB0byBoYW5kbGUgYm90aC5cclxuXHJcbiAgbGV0IHJlYWxGaWxlID0gbnVsbDtcclxuICBsZXQgcGFydHMgPSBmaWxlLnNwbGl0KC9bXFxcXFxcL11hcHAuYXNhcltcXFxcXFwvXS8pO1xyXG4gIGlmICghcGFydHNbMV0pIHtcclxuICAgIC8vIE5vdCB1c2luZyBhbiBBU0FSIGFyY2hpdmVcclxuICAgIHJlYWxGaWxlID0gY2FjaGVkUmVhbHBhdGgoZmlsZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIFdlIGRvIGFsbCB0aGlzIHNpbGxpbmVzcyB0byB3b3JrIGFyb3VuZFxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F0b20vZWxlY3Ryb24vaXNzdWVzLzQ2MTBcclxuICAgIHJlYWxGaWxlID0gYCR7Y2FjaGVkUmVhbHBhdGgocGFydHNbMF0pfS9hcHAuYXNhci8ke3BhcnRzWzFdfWA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVhbEZpbGUucmVwbGFjZSgvW1xcXFxcXC9dL2csICcvJyk7XHJcbn1cclxuIl19