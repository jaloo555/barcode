'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _compilerBase = require('../compiler-base');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const inputMimeTypes = ['text/typescript', 'text/tsx'];
let tss = null;
let ts = null;

/**
 * @access private
 */
class TypeScriptCompiler extends _compilerBase.SimpleCompilerBase {
  constructor() {
    super();

    this.compilerOptions = {
      module: 'commonjs',
      sourceMap: true,
      doSemanticChecks: true
    };
  }

  static getInputMimeTypes() {
    return inputMimeTypes;
  }

  compileSync(sourceCode, filePath) {
    tss = tss || require('@paulcbetts/typescript-simple');
    ts = ts || require('typescript');

    // NB: If you enable semantic checks with TSX, you're gonna have a
    //     Bad Time
    let extraOpts = { target: ts.ScriptTarget.ES6 };
    let isJsx = false;
    if (filePath.match(/\.tsx$/i)) {
      extraOpts.jsx = ts.JsxEmit.React;
      isJsx = true;
    }

    // NB: Work around TypeScriptSimple modifying the options object
    let compiler = new tss.TypeScriptSimple(Object.assign({}, this.compilerOptions, extraOpts), this.compilerOptions.doSemanticChecks && !isJsx);

    return {
      code: compiler.compile(sourceCode, _path2.default.basename(filePath)),
      mimeType: 'application/javascript'
    };
  }

  getCompilerVersion() {
    return require('typescript/package.json').version;
  }
}
exports.default = TypeScriptCompiler;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9qcy90eXBlc2NyaXB0LmpzIl0sIm5hbWVzIjpbImlucHV0TWltZVR5cGVzIiwidHNzIiwidHMiLCJUeXBlU2NyaXB0Q29tcGlsZXIiLCJjb25zdHJ1Y3RvciIsImNvbXBpbGVyT3B0aW9ucyIsIm1vZHVsZSIsInNvdXJjZU1hcCIsImRvU2VtYW50aWNDaGVja3MiLCJnZXRJbnB1dE1pbWVUeXBlcyIsImNvbXBpbGVTeW5jIiwic291cmNlQ29kZSIsImZpbGVQYXRoIiwicmVxdWlyZSIsImV4dHJhT3B0cyIsInRhcmdldCIsIlNjcmlwdFRhcmdldCIsIkVTNiIsImlzSnN4IiwibWF0Y2giLCJqc3giLCJKc3hFbWl0IiwiUmVhY3QiLCJjb21waWxlciIsIlR5cGVTY3JpcHRTaW1wbGUiLCJPYmplY3QiLCJhc3NpZ24iLCJjb2RlIiwiY29tcGlsZSIsImJhc2VuYW1lIiwibWltZVR5cGUiLCJnZXRDb21waWxlclZlcnNpb24iLCJ2ZXJzaW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7QUFDQTs7Ozs7O0FBRUEsTUFBTUEsaUJBQWlCLENBQUMsaUJBQUQsRUFBb0IsVUFBcEIsQ0FBdkI7QUFDQSxJQUFJQyxNQUFNLElBQVY7QUFDQSxJQUFJQyxLQUFLLElBQVQ7O0FBRUE7OztBQUdlLE1BQU1DLGtCQUFOLDBDQUFvRDtBQUNqRUMsZ0JBQWM7QUFDWjs7QUFFQSxTQUFLQyxlQUFMLEdBQXVCO0FBQ3JCQyxjQUFRLFVBRGE7QUFFckJDLGlCQUFXLElBRlU7QUFHckJDLHdCQUFrQjtBQUhHLEtBQXZCO0FBS0Q7O0FBRUQsU0FBT0MsaUJBQVAsR0FBMkI7QUFDekIsV0FBT1QsY0FBUDtBQUNEOztBQUVEVSxjQUFZQyxVQUFaLEVBQXdCQyxRQUF4QixFQUFrQztBQUNoQ1gsVUFBTUEsT0FBT1ksUUFBUSwrQkFBUixDQUFiO0FBQ0FYLFNBQUtBLE1BQU1XLFFBQVEsWUFBUixDQUFYOztBQUVBO0FBQ0E7QUFDQSxRQUFJQyxZQUFZLEVBQUNDLFFBQVFiLEdBQUdjLFlBQUgsQ0FBZ0JDLEdBQXpCLEVBQWhCO0FBQ0EsUUFBSUMsUUFBUSxLQUFaO0FBQ0EsUUFBSU4sU0FBU08sS0FBVCxDQUFlLFNBQWYsQ0FBSixFQUErQjtBQUM3QkwsZ0JBQVVNLEdBQVYsR0FBZ0JsQixHQUFHbUIsT0FBSCxDQUFXQyxLQUEzQjtBQUNBSixjQUFRLElBQVI7QUFDRDs7QUFFRDtBQUNBLFFBQUlLLFdBQVcsSUFBSXRCLElBQUl1QixnQkFBUixDQUNiQyxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFLckIsZUFBdkIsRUFBd0NTLFNBQXhDLENBRGEsRUFFYixLQUFLVCxlQUFMLENBQXFCRyxnQkFBckIsSUFBeUMsQ0FBQ1UsS0FGN0IsQ0FBZjs7QUFJQSxXQUFPO0FBQ0xTLFlBQU1KLFNBQVNLLE9BQVQsQ0FBaUJqQixVQUFqQixFQUE2QixlQUFLa0IsUUFBTCxDQUFjakIsUUFBZCxDQUE3QixDQUREO0FBRUxrQixnQkFBVTtBQUZMLEtBQVA7QUFJRDs7QUFFREMsdUJBQXFCO0FBQ25CLFdBQU9sQixRQUFRLHlCQUFSLEVBQW1DbUIsT0FBMUM7QUFDRDtBQXpDZ0U7a0JBQTlDN0Isa0IiLCJmaWxlIjoidHlwZXNjcmlwdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7U2ltcGxlQ29tcGlsZXJCYXNlfSBmcm9tICcuLi9jb21waWxlci1iYXNlJztcclxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcblxyXG5jb25zdCBpbnB1dE1pbWVUeXBlcyA9IFsndGV4dC90eXBlc2NyaXB0JywgJ3RleHQvdHN4J107XHJcbmxldCB0c3MgPSBudWxsO1xyXG5sZXQgdHMgPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIEBhY2Nlc3MgcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHlwZVNjcmlwdENvbXBpbGVyIGV4dGVuZHMgU2ltcGxlQ29tcGlsZXJCYXNlIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5jb21waWxlck9wdGlvbnMgPSB7XHJcbiAgICAgIG1vZHVsZTogJ2NvbW1vbmpzJyxcclxuICAgICAgc291cmNlTWFwOiB0cnVlLFxyXG4gICAgICBkb1NlbWFudGljQ2hlY2tzOiB0cnVlXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldElucHV0TWltZVR5cGVzKCkge1xyXG4gICAgcmV0dXJuIGlucHV0TWltZVR5cGVzO1xyXG4gIH1cclxuXHJcbiAgY29tcGlsZVN5bmMoc291cmNlQ29kZSwgZmlsZVBhdGgpIHtcclxuICAgIHRzcyA9IHRzcyB8fCByZXF1aXJlKCdAcGF1bGNiZXR0cy90eXBlc2NyaXB0LXNpbXBsZScpO1xyXG4gICAgdHMgPSB0cyB8fCByZXF1aXJlKCd0eXBlc2NyaXB0Jyk7XHJcblxyXG4gICAgLy8gTkI6IElmIHlvdSBlbmFibGUgc2VtYW50aWMgY2hlY2tzIHdpdGggVFNYLCB5b3UncmUgZ29ubmEgaGF2ZSBhXHJcbiAgICAvLyAgICAgQmFkIFRpbWVcclxuICAgIGxldCBleHRyYU9wdHMgPSB7dGFyZ2V0OiB0cy5TY3JpcHRUYXJnZXQuRVM2fTtcclxuICAgIGxldCBpc0pzeCA9IGZhbHNlO1xyXG4gICAgaWYgKGZpbGVQYXRoLm1hdGNoKC9cXC50c3gkL2kpKSB7XHJcbiAgICAgIGV4dHJhT3B0cy5qc3ggPSB0cy5Kc3hFbWl0LlJlYWN0O1xyXG4gICAgICBpc0pzeCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTkI6IFdvcmsgYXJvdW5kIFR5cGVTY3JpcHRTaW1wbGUgbW9kaWZ5aW5nIHRoZSBvcHRpb25zIG9iamVjdFxyXG4gICAgbGV0IGNvbXBpbGVyID0gbmV3IHRzcy5UeXBlU2NyaXB0U2ltcGxlKFxyXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbXBpbGVyT3B0aW9ucywgZXh0cmFPcHRzKSxcclxuICAgICAgdGhpcy5jb21waWxlck9wdGlvbnMuZG9TZW1hbnRpY0NoZWNrcyAmJiAhaXNKc3gpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNvZGU6IGNvbXBpbGVyLmNvbXBpbGUoc291cmNlQ29kZSwgcGF0aC5iYXNlbmFtZShmaWxlUGF0aCkpLFxyXG4gICAgICBtaW1lVHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZ2V0Q29tcGlsZXJWZXJzaW9uKCkge1xyXG4gICAgcmV0dXJuIHJlcXVpcmUoJ3R5cGVzY3JpcHQvcGFja2FnZS5qc29uJykudmVyc2lvbjtcclxuICB9XHJcbn1cclxuIl19