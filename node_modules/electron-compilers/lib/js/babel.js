'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _compilerBase = require('../compiler-base');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const mimeTypes = ['text/jsx', 'application/javascript'];
let babel = null;

/**
 * @access private
 */
class BabelCompiler extends _compilerBase.CompilerBase {
  constructor() {
    super();
  }

  static getInputMimeTypes() {
    return mimeTypes;
  }

  shouldCompileFile(fileName, compilerContext) {
    return _asyncToGenerator(function* () {
      return true;
    })();
  }

  determineDependentFiles(sourceCode, filePath, compilerContext) {
    return _asyncToGenerator(function* () {
      return [];
    })();
  }

  // NB: This method exists to stop Babel from trying to load plugins from the
  // app's node_modules directory, which in a production app doesn't have Babel
  // installed in it. Instead, we try to load from our entry point's node_modules
  // directory (i.e. Grunt perhaps), and if it doesn't work, just keep going.
  attemptToPreload(names, prefix) {
    const fixupModule = exp => {
      // NB: Some plugins like transform-decorators-legacy, use import/export
      // semantics, and others don't
      if ('default' in exp) return exp['default'];
      return exp;
    };

    const preloadStrategies = [() => names.map(x => fixupModule(require.main.require(`babel-${ prefix }-${ x }`))), () => {
      let nodeModulesAboveUs = _path2.default.resolve(__dirname, '..', '..', '..');
      return names.map(x => fixupModule(require(_path2.default.join(nodeModulesAboveUs, `babel-${ prefix }-${ x }`))));
    }, () => names.map(x => fixupModule(require(`babel-${ prefix }-${ x }`)))];

    for (let strategy of preloadStrategies) {
      try {
        return strategy();
      } catch (e) {
        continue;
      }
    }

    return null;
  }

  compile(sourceCode, filePath, compilerContext) {
    var _this = this;

    return _asyncToGenerator(function* () {
      babel = babel || require('babel-core');

      let opts = Object.assign({}, _this.compilerOptions, {
        filename: filePath,
        ast: false,
        babelrc: false
      });

      if ('plugins' in opts) {
        let plugins = _this.attemptToPreload(opts.plugins, 'plugin');
        if (plugins && plugins.length === opts.plugins.length) opts.plugins = plugins;
      }

      if ('presets' in opts) {
        let presets = _this.attemptToPreload(opts.presets, 'preset');
        if (presets && presets.length === opts.presets.length) opts.presets = presets;
      }

      return {
        code: babel.transform(sourceCode, opts).code,
        mimeType: 'application/javascript'
      };
    })();
  }

  shouldCompileFileSync(fileName, compilerContext) {
    return true;
  }

  determineDependentFilesSync(sourceCode, filePath, compilerContext) {
    return [];
  }

  compileSync(sourceCode, filePath, compilerContext) {
    babel = babel || require('babel-core');

    let opts = Object.assign({}, this.compilerOptions, {
      filename: filePath,
      ast: false,
      babelrc: false
    });

    if ('plugins' in opts) {
      let plugins = this.attemptToPreload(opts.plugins, 'plugin');
      if (plugins && plugins.length === opts.plugins.length) opts.plugins = plugins;
    }

    if ('presets' in opts) {
      let presets = this.attemptToPreload(opts.presets, 'preset');
      if (presets && presets.length === opts.presets.length) opts.presets = presets;
    }

    return {
      code: babel.transform(sourceCode, opts).code,
      mimeType: 'application/javascript'
    };
  }

  getCompilerVersion() {
    return require('babel-core/package.json').version;
  }
}
exports.default = BabelCompiler;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9qcy9iYWJlbC5qcyJdLCJuYW1lcyI6WyJtaW1lVHlwZXMiLCJiYWJlbCIsIkJhYmVsQ29tcGlsZXIiLCJjb25zdHJ1Y3RvciIsImdldElucHV0TWltZVR5cGVzIiwic2hvdWxkQ29tcGlsZUZpbGUiLCJmaWxlTmFtZSIsImNvbXBpbGVyQ29udGV4dCIsImRldGVybWluZURlcGVuZGVudEZpbGVzIiwic291cmNlQ29kZSIsImZpbGVQYXRoIiwiYXR0ZW1wdFRvUHJlbG9hZCIsIm5hbWVzIiwicHJlZml4IiwiZml4dXBNb2R1bGUiLCJleHAiLCJwcmVsb2FkU3RyYXRlZ2llcyIsIm1hcCIsIngiLCJyZXF1aXJlIiwibWFpbiIsIm5vZGVNb2R1bGVzQWJvdmVVcyIsInJlc29sdmUiLCJfX2Rpcm5hbWUiLCJqb2luIiwic3RyYXRlZ3kiLCJlIiwiY29tcGlsZSIsIm9wdHMiLCJPYmplY3QiLCJhc3NpZ24iLCJjb21waWxlck9wdGlvbnMiLCJmaWxlbmFtZSIsImFzdCIsImJhYmVscmMiLCJwbHVnaW5zIiwibGVuZ3RoIiwicHJlc2V0cyIsImNvZGUiLCJ0cmFuc2Zvcm0iLCJtaW1lVHlwZSIsInNob3VsZENvbXBpbGVGaWxlU3luYyIsImRldGVybWluZURlcGVuZGVudEZpbGVzU3luYyIsImNvbXBpbGVTeW5jIiwiZ2V0Q29tcGlsZXJWZXJzaW9uIiwidmVyc2lvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7QUFDQTs7Ozs7O0FBRUEsTUFBTUEsWUFBWSxDQUFDLFVBQUQsRUFBYSx3QkFBYixDQUFsQjtBQUNBLElBQUlDLFFBQVEsSUFBWjs7QUFHQTs7O0FBR2UsTUFBTUMsYUFBTixvQ0FBeUM7QUFDdERDLGdCQUFjO0FBQ1o7QUFDRDs7QUFFRCxTQUFPQyxpQkFBUCxHQUEyQjtBQUN6QixXQUFPSixTQUFQO0FBQ0Q7O0FBRUtLLG1CQUFOLENBQXdCQyxRQUF4QixFQUFrQ0MsZUFBbEMsRUFBbUQ7QUFBQTtBQUNqRCxhQUFPLElBQVA7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bUQ7QUFDakROLFlBQVFBLFNBQVNrQixRQUFRLFlBQVIsQ0FBakI7O0FBRUEsUUFBSVMsT0FBT0MsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0IsS0FBS0MsZUFBdkIsRUFBd0M7QUFDakRDLGdCQUFVdEIsUUFEdUM7QUFFakR1QixXQUFLLEtBRjRDO0FBR2pEQyxlQUFTO0FBSHdDLEtBQXhDLENBQVg7O0FBTUEsUUFBSSxhQUFhTixJQUFqQixFQUF1QjtBQUNyQixVQUFJTyxVQUFVLEtBQUt4QixnQkFBTCxDQUFzQmlCLEtBQUtPLE9BQTNCLEVBQW9DLFFBQXBDLENBQWQ7QUFDQSxVQUFJQSxXQUFXQSxRQUFRQyxNQUFSLEtBQW1CUixLQUFLTyxPQUFMLENBQWFDLE1BQS9DLEVBQXVEUixLQUFLTyxPQUFMLEdBQWVBLE9BQWY7QUFDeEQ7O0FBRUQsUUFBSSxhQUFhUCxJQUFqQixFQUF1QjtBQUNyQixVQUFJUyxVQUFVLEtBQUsxQixnQkFBTCxDQUFzQmlCLEtBQUtTLE9BQTNCLEVBQW9DLFFBQXBDLENBQWQ7QUFDQSxVQUFJQSxXQUFXQSxRQUFRRCxNQUFSLEtBQW1CUixLQUFLUyxPQUFMLENBQWFELE1BQS9DLEVBQXVEUixLQUFLUyxPQUFMLEdBQWVBLE9BQWY7QUFDeEQ7O0FBRUQsV0FBTztBQUNMQyxZQUFNckMsTUFBTXNDLFNBQU4sQ0FBZ0I5QixVQUFoQixFQUE0Qm1CLElBQTVCLEVBQWtDVSxJQURuQztBQUVMRSxnQkFBVTtBQUZMLEtBQVA7QUFJRDs7QUFFREksdUJBQXFCO0FBQ25CLFdBQU96QixRQUFRLHlCQUFSLEVBQW1DMEIsT0FBMUM7QUFDRDtBQTdHcUQ7a0JBQW5DM0MsYSIsImZpbGUiOiJiYWJlbC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQge0NvbXBpbGVyQmFzZX0gZnJvbSAnLi4vY29tcGlsZXItYmFzZSc7XHJcblxyXG5jb25zdCBtaW1lVHlwZXMgPSBbJ3RleHQvanN4JywgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnXTtcclxubGV0IGJhYmVsID0gbnVsbDtcclxuXHJcblxyXG4vKipcclxuICogQGFjY2VzcyBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYWJlbENvbXBpbGVyIGV4dGVuZHMgQ29tcGlsZXJCYXNlIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0SW5wdXRNaW1lVHlwZXMoKSB7XHJcbiAgICByZXR1cm4gbWltZVR5cGVzO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2hvdWxkQ29tcGlsZUZpbGUoZmlsZU5hbWUsIGNvbXBpbGVyQ29udGV4dCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBhc3luYyBkZXRlcm1pbmVEZXBlbmRlbnRGaWxlcyhzb3VyY2VDb2RlLCBmaWxlUGF0aCwgY29tcGlsZXJDb250ZXh0KSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG5cclxuICAvLyBOQjogVGhpcyBtZXRob2QgZXhpc3RzIHRvIHN0b3AgQmFiZWwgZnJvbSB0cnlpbmcgdG8gbG9hZCBwbHVnaW5zIGZyb20gdGhlXHJcbiAgLy8gYXBwJ3Mgbm9kZV9tb2R1bGVzIGRpcmVjdG9yeSwgd2hpY2ggaW4gYSBwcm9kdWN0aW9uIGFwcCBkb2Vzbid0IGhhdmUgQmFiZWxcclxuICAvLyBpbnN0YWxsZWQgaW4gaXQuIEluc3RlYWQsIHdlIHRyeSB0byBsb2FkIGZyb20gb3VyIGVudHJ5IHBvaW50J3Mgbm9kZV9tb2R1bGVzXHJcbiAgLy8gZGlyZWN0b3J5IChpLmUuIEdydW50IHBlcmhhcHMpLCBhbmQgaWYgaXQgZG9lc24ndCB3b3JrLCBqdXN0IGtlZXAgZ29pbmcuXHJcbiAgYXR0ZW1wdFRvUHJlbG9hZChuYW1lcywgcHJlZml4KSB7XHJcbiAgICBjb25zdCBmaXh1cE1vZHVsZSA9IChleHApID0+IHtcclxuICAgICAgLy8gTkI6IFNvbWUgcGx1Z2lucyBsaWtlIHRyYW5zZm9ybS1kZWNvcmF0b3JzLWxlZ2FjeSwgdXNlIGltcG9ydC9leHBvcnRcclxuICAgICAgLy8gc2VtYW50aWNzLCBhbmQgb3RoZXJzIGRvbid0XHJcbiAgICAgIGlmICgnZGVmYXVsdCcgaW4gZXhwKSByZXR1cm4gZXhwWydkZWZhdWx0J107XHJcbiAgICAgIHJldHVybiBleHA7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHByZWxvYWRTdHJhdGVnaWVzID0gW1xyXG4gICAgICAoKSA9PiBuYW1lcy5tYXAoKHgpID0+IGZpeHVwTW9kdWxlKHJlcXVpcmUubWFpbi5yZXF1aXJlKGBiYWJlbC0ke3ByZWZpeH0tJHt4fWApKSksXHJcbiAgICAgICgpID0+IHtcclxuICAgICAgICBsZXQgbm9kZU1vZHVsZXNBYm92ZVVzID0gcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uJywgJy4uJywgJy4uJyk7XHJcbiAgICAgICAgcmV0dXJuIG5hbWVzLm1hcCgoeCkgPT4gZml4dXBNb2R1bGUocmVxdWlyZShwYXRoLmpvaW4obm9kZU1vZHVsZXNBYm92ZVVzLCBgYmFiZWwtJHtwcmVmaXh9LSR7eH1gKSkpKTtcclxuICAgICAgfSxcclxuICAgICAgKCkgPT4gbmFtZXMubWFwKCh4KSA9PiBmaXh1cE1vZHVsZShyZXF1aXJlKGBiYWJlbC0ke3ByZWZpeH0tJHt4fWApKSlcclxuICAgIF07XHJcblxyXG4gICAgZm9yIChsZXQgc3RyYXRlZ3kgb2YgcHJlbG9hZFN0cmF0ZWdpZXMpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gc3RyYXRlZ3koKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBhc3luYyBjb21waWxlKHNvdXJjZUNvZGUsIGZpbGVQYXRoLCBjb21waWxlckNvbnRleHQpIHtcclxuICAgIGJhYmVsID0gYmFiZWwgfHwgcmVxdWlyZSgnYmFiZWwtY29yZScpO1xyXG5cclxuICAgIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21waWxlck9wdGlvbnMsIHtcclxuICAgICAgZmlsZW5hbWU6IGZpbGVQYXRoLFxyXG4gICAgICBhc3Q6IGZhbHNlLFxyXG4gICAgICBiYWJlbHJjOiBmYWxzZVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCdwbHVnaW5zJyBpbiBvcHRzKSB7XHJcbiAgICAgIGxldCBwbHVnaW5zID0gdGhpcy5hdHRlbXB0VG9QcmVsb2FkKG9wdHMucGx1Z2lucywgJ3BsdWdpbicpO1xyXG4gICAgICBpZiAocGx1Z2lucyAmJiBwbHVnaW5zLmxlbmd0aCA9PT0gb3B0cy5wbHVnaW5zLmxlbmd0aCkgb3B0cy5wbHVnaW5zID0gcGx1Z2lucztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoJ3ByZXNldHMnIGluIG9wdHMpIHtcclxuICAgICAgbGV0IHByZXNldHMgPSB0aGlzLmF0dGVtcHRUb1ByZWxvYWQob3B0cy5wcmVzZXRzLCAncHJlc2V0Jyk7XHJcbiAgICAgIGlmIChwcmVzZXRzICYmIHByZXNldHMubGVuZ3RoID09PSBvcHRzLnByZXNldHMubGVuZ3RoKSBvcHRzLnByZXNldHMgPSBwcmVzZXRzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNvZGU6IGJhYmVsLnRyYW5zZm9ybShzb3VyY2VDb2RlLCBvcHRzKS5jb2RlLFxyXG4gICAgICBtaW1lVHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc2hvdWxkQ29tcGlsZUZpbGVTeW5jKGZpbGVOYW1lLCBjb21waWxlckNvbnRleHQpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgZGV0ZXJtaW5lRGVwZW5kZW50RmlsZXNTeW5jKHNvdXJjZUNvZGUsIGZpbGVQYXRoLCBjb21waWxlckNvbnRleHQpIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcblxyXG4gIGNvbXBpbGVTeW5jKHNvdXJjZUNvZGUsIGZpbGVQYXRoLCBjb21waWxlckNvbnRleHQpIHtcclxuICAgIGJhYmVsID0gYmFiZWwgfHwgcmVxdWlyZSgnYmFiZWwtY29yZScpO1xyXG5cclxuICAgIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21waWxlck9wdGlvbnMsIHtcclxuICAgICAgZmlsZW5hbWU6IGZpbGVQYXRoLFxyXG4gICAgICBhc3Q6IGZhbHNlLFxyXG4gICAgICBiYWJlbHJjOiBmYWxzZVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCdwbHVnaW5zJyBpbiBvcHRzKSB7XHJcbiAgICAgIGxldCBwbHVnaW5zID0gdGhpcy5hdHRlbXB0VG9QcmVsb2FkKG9wdHMucGx1Z2lucywgJ3BsdWdpbicpO1xyXG4gICAgICBpZiAocGx1Z2lucyAmJiBwbHVnaW5zLmxlbmd0aCA9PT0gb3B0cy5wbHVnaW5zLmxlbmd0aCkgb3B0cy5wbHVnaW5zID0gcGx1Z2lucztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoJ3ByZXNldHMnIGluIG9wdHMpIHtcclxuICAgICAgbGV0IHByZXNldHMgPSB0aGlzLmF0dGVtcHRUb1ByZWxvYWQob3B0cy5wcmVzZXRzLCAncHJlc2V0Jyk7XHJcbiAgICAgIGlmIChwcmVzZXRzICYmIHByZXNldHMubGVuZ3RoID09PSBvcHRzLnByZXNldHMubGVuZ3RoKSBvcHRzLnByZXNldHMgPSBwcmVzZXRzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNvZGU6IGJhYmVsLnRyYW5zZm9ybShzb3VyY2VDb2RlLCBvcHRzKS5jb2RlLFxyXG4gICAgICBtaW1lVHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZ2V0Q29tcGlsZXJWZXJzaW9uKCkge1xyXG4gICAgcmV0dXJuIHJlcXVpcmUoJ2JhYmVsLWNvcmUvcGFja2FnZS5qc29uJykudmVyc2lvbjtcclxuICB9XHJcbn1cclxuIl19