'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _mimeTypes = require('@paulcbetts/mime-types');

var _mimeTypes2 = _interopRequireDefault(_mimeTypes);

var _compilerBase = require('../compiler-base');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const inputMimeTypes = ['text/html'];
let cheerio = null;

const d = require('debug-electron')('electron-compile:inline-html');

/**
 * @access private
 */
class InlineHtmlCompiler extends _compilerBase.CompilerBase {
  constructor(compileBlock, compileBlockSync) {
    super();

    this.compileBlock = compileBlock;
    this.compileBlockSync = compileBlockSync;
  }

  static createFromCompilers(compilersByMimeType) {
    d(`Setting up inline HTML compilers: ${ JSON.stringify(Object.keys(compilersByMimeType)) }`);

    let compileBlock = (() => {
      var _ref = _asyncToGenerator(function* (sourceCode, filePath, mimeType, ctx) {
        let realType = mimeType;
        if (!mimeType && ctx.tag === 'script') realType = 'application/javascript';

        if (!realType) return sourceCode;

        let compiler = compilersByMimeType[realType] || compilersByMimeType['text/plain'];
        let ext = _mimeTypes2.default.extension(realType);
        let fakeFile = `${ filePath }:inline_${ ctx.count }.${ ext }`;

        d(`Compiling inline block for ${ filePath } with mimeType ${ mimeType }`);
        if (!(yield compiler.shouldCompileFile(fakeFile, ctx))) return sourceCode;
        return (yield compiler.compileSync(sourceCode, fakeFile, ctx)).code;
      });

      return function compileBlock(_x, _x2, _x3, _x4) {
        return _ref.apply(this, arguments);
      };
    })();

    let compileBlockSync = (sourceCode, filePath, mimeType, ctx) => {
      let realType = mimeType;
      if (!mimeType && ctx.tag === 'script') realType = 'application/javascript';

      if (!realType) return sourceCode;

      let compiler = compilersByMimeType[realType] || compilersByMimeType['text/plain'];
      let ext = _mimeTypes2.default.extension(realType);
      let fakeFile = `${ filePath }:inline_${ ctx.count }.${ ext }`;

      d(`Compiling inline block for ${ filePath } with mimeType ${ mimeType }`);
      if (!compiler.shouldCompileFileSync(fakeFile, ctx)) return sourceCode;
      return compiler.compileSync(sourceCode, fakeFile, ctx).code;
    };

    return new InlineHtmlCompiler(compileBlock, compileBlockSync);
  }

  static getInputMimeTypes() {
    return inputMimeTypes;
  }

  shouldCompileFile(fileName, compilerContext) {
    return _asyncToGenerator(function* () {
      return true;
    })();
  }

  determineDependentFiles(sourceCode, filePath, compilerContext) {
    return _asyncToGenerator(function* () {
      return [];
    })();
  }

  each(nodes, selector) {
    return _asyncToGenerator(function* () {
      let acc = [];
      nodes.each(function (i, el) {
        let promise = selector(i, el);
        if (!promise) return false;

        acc.push(promise);
        return true;
      });

      yield Promise.all(acc);
    })();
  }

  eachSync(nodes, selector) {
    // NB: This method is here just so it's easier to mechanically
    // translate the async compile to compileSync
    return nodes.each((i, el) => {
      selector(i, el);
      return true;
    });
  }

  compile(sourceCode, filePath, compilerContext) {
    var _this = this;

    return _asyncToGenerator(function* () {
      cheerio = cheerio || require('cheerio');

      //Leave the attributes casing as it is, because of Angular 2 and maybe other case-sensitive frameworks
      let $ = cheerio.load(sourceCode, { lowerCaseAttributeNames: false });
      let toWait = [];

      let that = _this;
      let styleCount = 0;
      toWait.push(_this.each($('style'), (() => {
        var _ref2 = _asyncToGenerator(function* (i, el) {
          let mimeType = $(el).attr('type') || 'text/plain';

          let thisCtx = Object.assign({
            count: styleCount++,
            tag: 'style'
          }, compilerContext);

          let origText = $(el).text();
          let newText = yield that.compileBlock(origText, filePath, mimeType, thisCtx);

          if (origText !== newText) {
            $(el).text(newText);
            $(el).attr('type', 'text/css');
          }
        });

        return function (_x5, _x6) {
          return _ref2.apply(this, arguments);
        };
      })()));

      let scriptCount = 0;
      toWait.push(_this.each($('script'), (() => {
        var _ref3 = _asyncToGenerator(function* (i, el) {
          let src = $(el).attr('src');
          if (src && src.length > 2) {
            $(el).attr('src', InlineHtmlCompiler.fixupRelativeUrl(src));
            return;
          }

          let thisCtx = Object.assign({
            count: scriptCount++,
            tag: 'script'
          }, compilerContext);

          let mimeType = $(el).attr('type') || 'application/javascript';
          let origText = $(el).text();
          let newText = yield that.compileBlock(origText, filePath, mimeType, thisCtx);

          if (origText !== newText) {
            $(el).text(newText);
            $(el).attr('type', 'application/javascript');
          }
        });

        return function (_x7, _x8) {
          return _ref3.apply(this, arguments);
        };
      })()));

      $('link').map(function (i, el) {
        let href = $(el).attr('href');
        if (href && href.length > 2) {
          $(el).attr('href', InlineHtmlCompiler.fixupRelativeUrl(href));
        }

        // NB: In recent versions of Chromium, the link type MUST be text/css or
        // it will be flat-out ignored. Also I hate myself for hardcoding these.
        let type = $(el).attr('type');
        if (type === 'text/less' || type === 'text/stylus') $(el).attr('type', 'text/css');
      });

      $('x-require').map(function (i, el) {
        let src = $(el).attr('src');

        // File URL? Bail
        if (src.match(/^file:/i)) return;

        // Absolute path? Bail.
        if (src.match(/^([\/]|[A-Za-z]:)/i)) return;

        try {
          $(el).attr('src', _path2.default.resolve(_path2.default.dirname(filePath), src));
        } catch (e) {
          $(el).text(`${ e.message }\n${ e.stack }`);
        }
      });

      yield Promise.all(toWait);

      return {
        code: $.html(),
        mimeType: 'text/html'
      };
    })();
  }

  shouldCompileFileSync(fileName, compilerContext) {
    return true;
  }

  determineDependentFilesSync(sourceCode, filePath, compilerContext) {
    return [];
  }

  compileSync(sourceCode, filePath, compilerContext) {
    cheerio = cheerio || require('cheerio');

    //Leave the attributes casing as it is, because of Angular 2 and maybe other case-sensitive frameworks
    let $ = cheerio.load(sourceCode, { lowerCaseAttributeNames: false });

    let that = this;
    let styleCount = 0;
    this.eachSync($('style'), (() => {
      var _ref4 = _asyncToGenerator(function* (i, el) {
        let mimeType = $(el).attr('type');

        let thisCtx = Object.assign({
          count: styleCount++,
          tag: 'style'
        }, compilerContext);

        let origText = $(el).text();
        let newText = that.compileBlockSync(origText, filePath, mimeType, thisCtx);

        if (origText !== newText) {
          $(el).text(newText);
          $(el).attr('type', 'text/css');
        }
      });

      return function (_x9, _x10) {
        return _ref4.apply(this, arguments);
      };
    })());

    let scriptCount = 0;
    this.eachSync($('script'), (() => {
      var _ref5 = _asyncToGenerator(function* (i, el) {
        let src = $(el).attr('src');
        if (src && src.length > 2) {
          $(el).attr('src', InlineHtmlCompiler.fixupRelativeUrl(src));
          return;
        }

        let thisCtx = Object.assign({
          count: scriptCount++,
          tag: 'script'
        }, compilerContext);

        let mimeType = $(el).attr('type');

        let oldText = $(el).text();
        let newText = that.compileBlockSync(oldText, filePath, mimeType, thisCtx);

        if (oldText !== newText) {
          $(el).text(newText);
          $(el).attr('type', 'application/javascript');
        }
      });

      return function (_x11, _x12) {
        return _ref5.apply(this, arguments);
      };
    })());

    $('link').map((i, el) => {
      let href = $(el).attr('href');
      if (href && href.length > 2) {
        $(el).attr('href', InlineHtmlCompiler.fixupRelativeUrl(href));
      }

      // NB: In recent versions of Chromium, the link type MUST be text/css or
      // it will be flat-out ignored. Also I hate myself for hardcoding these.
      let type = $(el).attr('type');
      if (type === 'text/less' || type === 'text/stylus') $(el).attr('type', 'text/css');
    });

    $('x-require').map((i, el) => {
      let src = $(el).attr('src');

      // File URL? Bail
      if (src.match(/^file:/i)) return;

      // Absolute path? Bail.
      if (src.match(/^([\/]|[A-Za-z]:)/i)) return;

      try {
        $(el).attr('src', _path2.default.resolve(_path2.default.dirname(filePath), src));
      } catch (e) {
        $(el).text(`${ e.message }\n${ e.stack }`);
      }
    });

    return {
      code: $.html(),
      mimeType: 'text/html'
    };
  }

  getCompilerVersion() {
    let thisVersion = require('../../package.json').version;
    let compilers = this.allCompilers || [];
    let otherVersions = compilers.map(x => x.getCompilerVersion).join();

    return `${ thisVersion },${ otherVersions }`;
  }

  static fixupRelativeUrl(url) {
    if (!url.match(/^\/\//)) return url;
    return `https:${ url }`;
  }
}
exports.default = InlineHtmlCompiler;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9odG1sL2lubGluZS1odG1sLmpzIl0sIm5hbWVzIjpbImlucHV0TWltZVR5cGVzIiwiY2hlZXJpbyIsImQiLCJyZXF1aXJlIiwiSW5saW5lSHRtbENvbXBpbGVyIiwiY29uc3RydWN0b3IiLCJjb21waWxlQmxvY2siLCJjb21waWxlQmxvY2tTeW5jIiwiY3JlYXRlRnJvbUNvbXBpbGVycyIsImNvbXBpbGVyc0J5TWltZVR5cGUiLCJKU09OIiwic3RyaW5naWZ5IiwiT2JqZWN0Iiwia2V5cyIsInNvdXJjZUNvZGUiLCJmaWxlUGF0aCIsIm1pbWVUeXBlIiwiY3R4IiwicmVhbFR5cGUiLCJ0YWciLCJjb21waWxlciIsImV4dCIsImV4dGVuc2lvbiIsImZha2VGaWxlIiwiY291bnQiLCJzaG91bGRDb21waWxlRmlsZSIsImNvbXBpbGVTeW5jIiwiY29kZSIsInNob3VsZENvbXBpbGVGaWxlU3luYyIsImdldElucHV0TWltZVR5cGVzIiwiZmlsZU5hbWUiLCJjb21waWxlckNvbnRleHQiLCJkZXRlcm1pbmVEZXBlbmRlbnRGaWxlcyIsImVhY2giLCJub2RlcyIsInNlbGVjdG9yIiwiYWNjIiwiaSIsImVsIiwicHJvbWlzZSIsInB1c2giLCJQcm9taXNlIiwiYWxsIiwiZWFjaFN5bmMiLCJjb21waWxlIiwiJCIsImxvYWQiLCJsb3dlckNhc2VBdHRyaWJ1dGVOYW1lcyIsInRvV2FpdCIsInRoYXQiLCJzdHlsZUNvdW50IiwiYXR0ciIsInRoaXNDdHgiLCJhc3NpZ24iLCJvcmlnVGV4dCIsInRleHQiLCJuZXdUZXh0Iiwic2NyaXB0Q291bnQiLCJzcmMiLCJsZW5ndGgiLCJmaXh1cFJlbGF0aXZlVXJsIiwibWFwIiwiaHJlZiIsInR5cGUiLCJtYXRjaCIsInJlc29sdmUiLCJkaXJuYW1lIiwiZSIsIm1lc3NhZ2UiLCJzdGFjayIsImh0bWwiLCJkZXRlcm1pbmVEZXBlbmRlbnRGaWxlc1N5bmMiLCJvbGRUZXh0IiwiZ2V0Q29tcGlsZXJWZXJzaW9uIiwidGhpc1ZlcnNpb24iLCJ2ZXJzaW9uIiwiY29tcGlsZXJzIiwiYWxsQ29tcGlsZXJzIiwib3RoZXJWZXJzaW9ucyIsIngiLCJqb2luIiwidXJsIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLE1BQU1BLGlCQUFpQixDQUFDLFdBQUQsQ0FBdkI7QUFDQSxJQUFJQyxVQUFVLElBQWQ7O0FBRUEsTUFBTUMsSUFBSUMsUUFBUSxnQkFBUixFQUEwQiw4QkFBMUIsQ0FBVjs7QUFFQTs7O0FBR2UsTUFBTUMsa0JBQU4sb0NBQThDO0FBQzNEQyxjQUFZQyxZQUFaLEVBQTBCQyxnQkFBMUIsRUFBNEM7QUFDMUM7O0FBRUEsU0FBS0QsWUFBTCxHQUFvQkEsWUFBcEI7QUFDQSxTQUFLQyxnQkFBTCxHQUF3QkEsZ0JBQXhCO0FBQ0Q7O0FBRUQsU0FBT0MsbUJBQVAsQ0FBMkJDLG1CQUEzQixFQUFnRDtBQUM5Q1AsTUFBRyxzQ0FBb0NRLEtBQUtDLFNBQUwsQ0FBZUMsT0FBT0MsSUFBUCxDQUFZSixtQkFBWixDQUFmLENBQWlELEdBQXhGOztBQUVBLFFBQUlIO0FBQUEsbUNBQWUsV0FBT1EsVUFBUCxFQUFtQkMsUUFBbkIsRUFBNkJDLFFBQTdCLEVBQXVDQyxHQUF2QyxFQUErQztBQUNoRSxZQUFJQyxXQUFXRixRQUFmO0FBQ0EsWUFBSSxDQUFDQSxRQUFELElBQWFDLElBQUlFLEdBQUosS0FBWSxRQUE3QixFQUF1Q0QsV0FBVyx3QkFBWDs7QUFFdkMsWUFBSSxDQUFDQSxRQUFMLEVBQWUsT0FBT0osVUFBUDs7QUFFZixZQUFJTSxXQUFXWCxvQkFBb0JTLFFBQXBCLEtBQWlDVCxvQkFBb0IsWUFBcEIsQ0FBaEQ7QUFDQSxZQUFJWSxNQUFNLG9CQUFVQyxTQUFWLENBQW9CSixRQUFwQixDQUFWO0FBQ0EsWUFBSUssV0FBWSxJQUFFUixRQUFTLGFBQVVFLElBQUlPLEtBQU0sTUFBR0gsR0FBSSxHQUF0RDs7QUFFQW5CLFVBQUcsK0JBQTZCYSxRQUFTLG9CQUFpQkMsUUFB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Q0FBVjs7QUFFQTtBQUNBLFVBQUlPLElBQUlNLEtBQUosQ0FBVSxTQUFWLENBQUosRUFBMEI7O0FBRTFCO0FBQ0EsVUFBSU4sSUFBSU0sS0FBSixDQUFVLG9CQUFWLENBQUosRUFBcUM7O0FBRXJDLFVBQUk7QUFDRm5CLFVBQUVQLEVBQUYsRUFBTWEsSUFBTixDQUFXLEtBQVgsRUFBa0IsZUFBS2MsT0FBTCxDQUFhLGVBQUtDLE9BQUwsQ0FBYW5ELFFBQWIsQ0FBYixFQUFxQzJDLEdBQXJDLENBQWxCO0FBQ0QsT0FGRCxDQUVFLE9BQU9TLENBQVAsRUFBVTtBQUNWdEIsVUFBRVAsRUFBRixFQUFNaUIsSUFBTixDQUFZLElBQUVZLEVBQUVDLE9BQVEsT0FBSUQsRUFBRUUsS0FBTSxHQUFwQztBQUNEO0FBQ0YsS0FkRDs7QUFnQkEsV0FBTztBQUNMMUMsWUFBTWtCLEVBQUV5QixJQUFGLEVBREQ7QUFFTHRELGdCQUFVO0FBRkwsS0FBUDtBQUlEOztBQUVEeUQsdUJBQXFCO0FBQ25CLFFBQUlDLGNBQWN2RSxRQUFRLG9CQUFSLEVBQThCd0UsT0FBaEQ7QUFDQSxRQUFJQyxZQUFZLEtBQUtDLFlBQUwsSUFBcUIsRUFBckM7QUFDQSxRQUFJQyxnQkFBZ0JGLFVBQVVmLEdBQVYsQ0FBZWtCLENBQUQsSUFBT0EsRUFBRU4sa0JBQXZCLEVBQTJDTyxJQUEzQyxFQUFwQjs7QUFFQSxXQUFRLElBQUVOLFdBQVksTUFBR0ksYUFBYyxHQUF2QztBQUNEOztBQUVELFNBQU9sQixnQkFBUCxDQUF3QnFCLEdBQXhCLEVBQTZCO0FBQzNCLFFBQUksQ0FBQ0EsSUFBSWpCLEtBQUosQ0FBVSxPQUFWLENBQUwsRUFBeUIsT0FBT2lCLEdBQVA7QUFDekIsV0FBUSxVQUFRQSxHQUFJLEdBQXBCO0FBQ0Q7QUFyUTBEO2tCQUF4QzdFLGtCIiwiZmlsZSI6ImlubGluZS1odG1sLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCBtaW1lVHlwZXMgZnJvbSAnQHBhdWxjYmV0dHMvbWltZS10eXBlcyc7XHJcbmltcG9ydCB7Q29tcGlsZXJCYXNlfSBmcm9tICcuLi9jb21waWxlci1iYXNlJztcclxuXHJcbmNvbnN0IGlucHV0TWltZVR5cGVzID0gWyd0ZXh0L2h0bWwnXTtcclxubGV0IGNoZWVyaW8gPSBudWxsO1xyXG5cclxuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnLWVsZWN0cm9uJykoJ2VsZWN0cm9uLWNvbXBpbGU6aW5saW5lLWh0bWwnKTtcclxuXHJcbi8qKlxyXG4gKiBAYWNjZXNzIHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElubGluZUh0bWxDb21waWxlciBleHRlbmRzIENvbXBpbGVyQmFzZSB7XHJcbiAgY29uc3RydWN0b3IoY29tcGlsZUJsb2NrLCBjb21waWxlQmxvY2tTeW5jKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMuY29tcGlsZUJsb2NrID0gY29tcGlsZUJsb2NrO1xyXG4gICAgdGhpcy5jb21waWxlQmxvY2tTeW5jID0gY29tcGlsZUJsb2NrU3luYztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjcmVhdGVGcm9tQ29tcGlsZXJzKGNvbXBpbGVyc0J5TWltZVR5cGUpIHtcclxuICAgIGQoYFNldHRpbmcgdXAgaW5saW5lIEhUTUwgY29tcGlsZXJzOiAke0pTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKGNvbXBpbGVyc0J5TWltZVR5cGUpKX1gKTtcclxuXHJcbiAgICBsZXQgY29tcGlsZUJsb2NrID0gYXN5bmMgKHNvdXJjZUNvZGUsIGZpbGVQYXRoLCBtaW1lVHlwZSwgY3R4KSA9PiB7XHJcbiAgICAgIGxldCByZWFsVHlwZSA9IG1pbWVUeXBlO1xyXG4gICAgICBpZiAoIW1pbWVUeXBlICYmIGN0eC50YWcgPT09ICdzY3JpcHQnKSByZWFsVHlwZSA9ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JztcclxuXHJcbiAgICAgIGlmICghcmVhbFR5cGUpIHJldHVybiBzb3VyY2VDb2RlO1xyXG5cclxuICAgICAgbGV0IGNvbXBpbGVyID0gY29tcGlsZXJzQnlNaW1lVHlwZVtyZWFsVHlwZV0gfHwgY29tcGlsZXJzQnlNaW1lVHlwZVsndGV4dC9wbGFpbiddO1xyXG4gICAgICBsZXQgZXh0ID0gbWltZVR5cGVzLmV4dGVuc2lvbihyZWFsVHlwZSk7XHJcbiAgICAgIGxldCBmYWtlRmlsZSA9IGAke2ZpbGVQYXRofTppbmxpbmVfJHtjdHguY291bnR9LiR7ZXh0fWA7XHJcblxyXG4gICAgICBkKGBDb21waWxpbmcgaW5saW5lIGJsb2NrIGZvciAke2ZpbGVQYXRofSB3aXRoIG1pbWVUeXBlICR7bWltZVR5cGV9YCk7XHJcbiAgICAgIGlmICghKGF3YWl0IGNvbXBpbGVyLnNob3VsZENvbXBpbGVGaWxlKGZha2VGaWxlLCBjdHgpKSkgcmV0dXJuIHNvdXJjZUNvZGU7XHJcbiAgICAgIHJldHVybiAoYXdhaXQgY29tcGlsZXIuY29tcGlsZVN5bmMoc291cmNlQ29kZSwgZmFrZUZpbGUsIGN0eCkpLmNvZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIGxldCBjb21waWxlQmxvY2tTeW5jID0gKHNvdXJjZUNvZGUsIGZpbGVQYXRoLCBtaW1lVHlwZSwgY3R4KSA9PiB7XHJcbiAgICAgIGxldCByZWFsVHlwZSA9IG1pbWVUeXBlO1xyXG4gICAgICBpZiAoIW1pbWVUeXBlICYmIGN0eC50YWcgPT09ICdzY3JpcHQnKSByZWFsVHlwZSA9ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JztcclxuXHJcbiAgICAgIGlmICghcmVhbFR5cGUpIHJldHVybiBzb3VyY2VDb2RlO1xyXG5cclxuICAgICAgbGV0IGNvbXBpbGVyID0gY29tcGlsZXJzQnlNaW1lVHlwZVtyZWFsVHlwZV0gfHwgY29tcGlsZXJzQnlNaW1lVHlwZVsndGV4dC9wbGFpbiddO1xyXG4gICAgICBsZXQgZXh0ID0gbWltZVR5cGVzLmV4dGVuc2lvbihyZWFsVHlwZSk7XHJcbiAgICAgIGxldCBmYWtlRmlsZSA9IGAke2ZpbGVQYXRofTppbmxpbmVfJHtjdHguY291bnR9LiR7ZXh0fWA7XHJcblxyXG4gICAgICBkKGBDb21waWxpbmcgaW5saW5lIGJsb2NrIGZvciAke2ZpbGVQYXRofSB3aXRoIG1pbWVUeXBlICR7bWltZVR5cGV9YCk7XHJcbiAgICAgIGlmICghY29tcGlsZXIuc2hvdWxkQ29tcGlsZUZpbGVTeW5jKGZha2VGaWxlLCBjdHgpKSByZXR1cm4gc291cmNlQ29kZTtcclxuICAgICAgcmV0dXJuIGNvbXBpbGVyLmNvbXBpbGVTeW5jKHNvdXJjZUNvZGUsIGZha2VGaWxlLCBjdHgpLmNvZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBuZXcgSW5saW5lSHRtbENvbXBpbGVyKGNvbXBpbGVCbG9jaywgY29tcGlsZUJsb2NrU3luYyk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0SW5wdXRNaW1lVHlwZXMoKSB7XHJcbiAgICByZXR1cm4gaW5wdXRNaW1lVHlwZXM7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzaG91bGRDb21waWxlRmlsZShmaWxlTmFtZSwgY29tcGlsZXJDb250ZXh0KSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRldGVybWluZURlcGVuZGVudEZpbGVzKHNvdXJjZUNvZGUsIGZpbGVQYXRoLCBjb21waWxlckNvbnRleHQpIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGVhY2gobm9kZXMsIHNlbGVjdG9yKSB7XHJcbiAgICBsZXQgYWNjID0gW107XHJcbiAgICBub2Rlcy5lYWNoKChpLCBlbCkgPT4ge1xyXG4gICAgICBsZXQgcHJvbWlzZSA9IHNlbGVjdG9yKGksZWwpO1xyXG4gICAgICBpZiAoIXByb21pc2UpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgIGFjYy5wdXNoKHByb21pc2UpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pO1xyXG5cclxuICAgIGF3YWl0IFByb21pc2UuYWxsKGFjYyk7XHJcbiAgfVxyXG5cclxuICBlYWNoU3luYyhub2Rlcywgc2VsZWN0b3IpIHtcclxuICAgIC8vIE5COiBUaGlzIG1ldGhvZCBpcyBoZXJlIGp1c3Qgc28gaXQncyBlYXNpZXIgdG8gbWVjaGFuaWNhbGx5XHJcbiAgICAvLyB0cmFuc2xhdGUgdGhlIGFzeW5jIGNvbXBpbGUgdG8gY29tcGlsZVN5bmNcclxuICAgIHJldHVybiBub2Rlcy5lYWNoKChpLGVsKSA9PiB7XHJcbiAgICAgIHNlbGVjdG9yKGksZWwpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgY29tcGlsZShzb3VyY2VDb2RlLCBmaWxlUGF0aCwgY29tcGlsZXJDb250ZXh0KSB7XHJcbiAgICBjaGVlcmlvID0gY2hlZXJpbyB8fCByZXF1aXJlKCdjaGVlcmlvJyk7XHJcbiAgICBcclxuICAgIC8vTGVhdmUgdGhlIGF0dHJpYnV0ZXMgY2FzaW5nIGFzIGl0IGlzLCBiZWNhdXNlIG9mIEFuZ3VsYXIgMiBhbmQgbWF5YmUgb3RoZXIgY2FzZS1zZW5zaXRpdmUgZnJhbWV3b3Jrc1xyXG4gICAgbGV0ICQgPSBjaGVlcmlvLmxvYWQoc291cmNlQ29kZSwge2xvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzOiBmYWxzZX0pO1xyXG4gICAgbGV0IHRvV2FpdCA9IFtdO1xyXG5cclxuICAgIGxldCB0aGF0ID0gdGhpcztcclxuICAgIGxldCBzdHlsZUNvdW50ID0gMDtcclxuICAgIHRvV2FpdC5wdXNoKHRoaXMuZWFjaCgkKCdzdHlsZScpLCBhc3luYyAoaSwgZWwpID0+IHtcclxuICAgICAgbGV0IG1pbWVUeXBlID0gJChlbCkuYXR0cigndHlwZScpIHx8ICd0ZXh0L3BsYWluJztcclxuXHJcbiAgICAgIGxldCB0aGlzQ3R4ID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAgY291bnQ6IHN0eWxlQ291bnQrKyxcclxuICAgICAgICB0YWc6ICdzdHlsZSdcclxuICAgICAgfSwgY29tcGlsZXJDb250ZXh0KTtcclxuXHJcbiAgICAgIGxldCBvcmlnVGV4dCA9ICQoZWwpLnRleHQoKTtcclxuICAgICAgbGV0IG5ld1RleHQgPSBhd2FpdCB0aGF0LmNvbXBpbGVCbG9jayhvcmlnVGV4dCwgZmlsZVBhdGgsIG1pbWVUeXBlLCB0aGlzQ3R4KTtcclxuXHJcbiAgICAgIGlmIChvcmlnVGV4dCAhPT0gbmV3VGV4dCkge1xyXG4gICAgICAgICQoZWwpLnRleHQobmV3VGV4dCk7XHJcbiAgICAgICAgJChlbCkuYXR0cigndHlwZScsICd0ZXh0L2NzcycpO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gICAgbGV0IHNjcmlwdENvdW50ID0gMDtcclxuICAgIHRvV2FpdC5wdXNoKHRoaXMuZWFjaCgkKCdzY3JpcHQnKSwgYXN5bmMgKGksIGVsKSA9PiB7XHJcbiAgICAgIGxldCBzcmMgPSAkKGVsKS5hdHRyKCdzcmMnKTtcclxuICAgICAgaWYgKHNyYyAmJiBzcmMubGVuZ3RoID4gMikge1xyXG4gICAgICAgICQoZWwpLmF0dHIoJ3NyYycsIElubGluZUh0bWxDb21waWxlci5maXh1cFJlbGF0aXZlVXJsKHNyYykpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHRoaXNDdHggPSBPYmplY3QuYXNzaWduKHtcclxuICAgICAgICBjb3VudDogc2NyaXB0Q291bnQrKyxcclxuICAgICAgICB0YWc6ICdzY3JpcHQnXHJcbiAgICAgIH0sIGNvbXBpbGVyQ29udGV4dCk7XHJcblxyXG4gICAgICBsZXQgbWltZVR5cGUgPSAkKGVsKS5hdHRyKCd0eXBlJykgfHwgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnO1xyXG4gICAgICBsZXQgb3JpZ1RleHQgPSAkKGVsKS50ZXh0KCk7XHJcbiAgICAgIGxldCBuZXdUZXh0ID0gYXdhaXQgdGhhdC5jb21waWxlQmxvY2sob3JpZ1RleHQsIGZpbGVQYXRoLCBtaW1lVHlwZSwgdGhpc0N0eCk7XHJcblxyXG4gICAgICBpZiAob3JpZ1RleHQgIT09IG5ld1RleHQpIHtcclxuICAgICAgICAkKGVsKS50ZXh0KG5ld1RleHQpO1xyXG4gICAgICAgICQoZWwpLmF0dHIoJ3R5cGUnLCAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcpO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gICAgJCgnbGluaycpLm1hcCgoaSwgZWwpID0+IHtcclxuICAgICAgbGV0IGhyZWYgPSAkKGVsKS5hdHRyKCdocmVmJyk7XHJcbiAgICAgIGlmIChocmVmICYmIGhyZWYubGVuZ3RoID4gMikgeyAkKGVsKS5hdHRyKCdocmVmJywgSW5saW5lSHRtbENvbXBpbGVyLmZpeHVwUmVsYXRpdmVVcmwoaHJlZikpOyB9XHJcblxyXG4gICAgICAvLyBOQjogSW4gcmVjZW50IHZlcnNpb25zIG9mIENocm9taXVtLCB0aGUgbGluayB0eXBlIE1VU1QgYmUgdGV4dC9jc3Mgb3JcclxuICAgICAgLy8gaXQgd2lsbCBiZSBmbGF0LW91dCBpZ25vcmVkLiBBbHNvIEkgaGF0ZSBteXNlbGYgZm9yIGhhcmRjb2RpbmcgdGhlc2UuXHJcbiAgICAgIGxldCB0eXBlID0gJChlbCkuYXR0cigndHlwZScpO1xyXG4gICAgICBpZiAodHlwZSA9PT0gJ3RleHQvbGVzcycgfHwgdHlwZSA9PT0gJ3RleHQvc3R5bHVzJykgJChlbCkuYXR0cigndHlwZScsICd0ZXh0L2NzcycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgJCgneC1yZXF1aXJlJykubWFwKChpLCBlbCkgPT4ge1xyXG4gICAgICBsZXQgc3JjID0gJChlbCkuYXR0cignc3JjJyk7XHJcblxyXG4gICAgICAvLyBGaWxlIFVSTD8gQmFpbFxyXG4gICAgICBpZiAoc3JjLm1hdGNoKC9eZmlsZTovaSkpIHJldHVybjtcclxuXHJcbiAgICAgIC8vIEFic29sdXRlIHBhdGg/IEJhaWwuXHJcbiAgICAgIGlmIChzcmMubWF0Y2goL14oW1xcL118W0EtWmEtel06KS9pKSkgcmV0dXJuO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICAkKGVsKS5hdHRyKCdzcmMnLCBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGZpbGVQYXRoKSwgc3JjKSk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAkKGVsKS50ZXh0KGAke2UubWVzc2FnZX1cXG4ke2Uuc3RhY2t9YCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGF3YWl0IFByb21pc2UuYWxsKHRvV2FpdCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY29kZTogJC5odG1sKCksXHJcbiAgICAgIG1pbWVUeXBlOiAndGV4dC9odG1sJ1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHNob3VsZENvbXBpbGVGaWxlU3luYyhmaWxlTmFtZSwgY29tcGlsZXJDb250ZXh0KSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGRldGVybWluZURlcGVuZGVudEZpbGVzU3luYyhzb3VyY2VDb2RlLCBmaWxlUGF0aCwgY29tcGlsZXJDb250ZXh0KSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG5cclxuICBjb21waWxlU3luYyhzb3VyY2VDb2RlLCBmaWxlUGF0aCwgY29tcGlsZXJDb250ZXh0KSB7XHJcbiAgICBjaGVlcmlvID0gY2hlZXJpbyB8fCByZXF1aXJlKCdjaGVlcmlvJyk7XHJcbiAgICBcclxuICAgIC8vTGVhdmUgdGhlIGF0dHJpYnV0ZXMgY2FzaW5nIGFzIGl0IGlzLCBiZWNhdXNlIG9mIEFuZ3VsYXIgMiBhbmQgbWF5YmUgb3RoZXIgY2FzZS1zZW5zaXRpdmUgZnJhbWV3b3Jrc1xyXG4gICAgbGV0ICQgPSBjaGVlcmlvLmxvYWQoc291cmNlQ29kZSwge2xvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzOiBmYWxzZX0pO1xyXG5cclxuICAgIGxldCB0aGF0ID0gdGhpcztcclxuICAgIGxldCBzdHlsZUNvdW50ID0gMDtcclxuICAgIHRoaXMuZWFjaFN5bmMoJCgnc3R5bGUnKSwgYXN5bmMgKGksIGVsKSA9PiB7XHJcbiAgICAgIGxldCBtaW1lVHlwZSA9ICQoZWwpLmF0dHIoJ3R5cGUnKTtcclxuXHJcbiAgICAgIGxldCB0aGlzQ3R4ID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAgY291bnQ6IHN0eWxlQ291bnQrKyxcclxuICAgICAgICB0YWc6ICdzdHlsZSdcclxuICAgICAgfSwgY29tcGlsZXJDb250ZXh0KTtcclxuXHJcbiAgICAgIGxldCBvcmlnVGV4dCA9ICQoZWwpLnRleHQoKTtcclxuICAgICAgbGV0IG5ld1RleHQgPSB0aGF0LmNvbXBpbGVCbG9ja1N5bmMob3JpZ1RleHQsIGZpbGVQYXRoLCBtaW1lVHlwZSwgdGhpc0N0eCk7XHJcblxyXG4gICAgICBpZiAob3JpZ1RleHQgIT09IG5ld1RleHQpIHtcclxuICAgICAgICAkKGVsKS50ZXh0KG5ld1RleHQpO1xyXG4gICAgICAgICQoZWwpLmF0dHIoJ3R5cGUnLCAndGV4dC9jc3MnKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IHNjcmlwdENvdW50ID0gMDtcclxuICAgIHRoaXMuZWFjaFN5bmMoJCgnc2NyaXB0JyksIGFzeW5jIChpLCBlbCkgPT4ge1xyXG4gICAgICBsZXQgc3JjID0gJChlbCkuYXR0cignc3JjJyk7XHJcbiAgICAgIGlmIChzcmMgJiYgc3JjLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAkKGVsKS5hdHRyKCdzcmMnLCBJbmxpbmVIdG1sQ29tcGlsZXIuZml4dXBSZWxhdGl2ZVVybChzcmMpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCB0aGlzQ3R4ID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAgY291bnQ6IHNjcmlwdENvdW50KyssXHJcbiAgICAgICAgdGFnOiAnc2NyaXB0J1xyXG4gICAgICB9LCBjb21waWxlckNvbnRleHQpO1xyXG5cclxuICAgICAgbGV0IG1pbWVUeXBlID0gJChlbCkuYXR0cigndHlwZScpO1xyXG5cclxuICAgICAgbGV0IG9sZFRleHQgPSAkKGVsKS50ZXh0KCk7XHJcbiAgICAgIGxldCBuZXdUZXh0ID0gdGhhdC5jb21waWxlQmxvY2tTeW5jKG9sZFRleHQsIGZpbGVQYXRoLCBtaW1lVHlwZSwgdGhpc0N0eCk7XHJcblxyXG4gICAgICBpZiAob2xkVGV4dCAhPT0gbmV3VGV4dCkge1xyXG4gICAgICAgICQoZWwpLnRleHQobmV3VGV4dCk7XHJcbiAgICAgICAgJChlbCkuYXR0cigndHlwZScsICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0Jyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgICQoJ2xpbmsnKS5tYXAoKGksIGVsKSA9PiB7XHJcbiAgICAgIGxldCBocmVmID0gJChlbCkuYXR0cignaHJlZicpO1xyXG4gICAgICBpZiAoaHJlZiAmJiBocmVmLmxlbmd0aCA+IDIpIHsgJChlbCkuYXR0cignaHJlZicsIElubGluZUh0bWxDb21waWxlci5maXh1cFJlbGF0aXZlVXJsKGhyZWYpKTsgfVxyXG5cclxuICAgICAgLy8gTkI6IEluIHJlY2VudCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSwgdGhlIGxpbmsgdHlwZSBNVVNUIGJlIHRleHQvY3NzIG9yXHJcbiAgICAgIC8vIGl0IHdpbGwgYmUgZmxhdC1vdXQgaWdub3JlZC4gQWxzbyBJIGhhdGUgbXlzZWxmIGZvciBoYXJkY29kaW5nIHRoZXNlLlxyXG4gICAgICBsZXQgdHlwZSA9ICQoZWwpLmF0dHIoJ3R5cGUnKTtcclxuICAgICAgaWYgKHR5cGUgPT09ICd0ZXh0L2xlc3MnIHx8IHR5cGUgPT09ICd0ZXh0L3N0eWx1cycpICQoZWwpLmF0dHIoJ3R5cGUnLCAndGV4dC9jc3MnKTtcclxuICAgIH0pO1xyXG5cclxuICAgICQoJ3gtcmVxdWlyZScpLm1hcCgoaSwgZWwpID0+IHtcclxuICAgICAgbGV0IHNyYyA9ICQoZWwpLmF0dHIoJ3NyYycpO1xyXG5cclxuICAgICAgLy8gRmlsZSBVUkw/IEJhaWxcclxuICAgICAgaWYgKHNyYy5tYXRjaCgvXmZpbGU6L2kpKSByZXR1cm47XHJcblxyXG4gICAgICAvLyBBYnNvbHV0ZSBwYXRoPyBCYWlsLlxyXG4gICAgICBpZiAoc3JjLm1hdGNoKC9eKFtcXC9dfFtBLVphLXpdOikvaSkpIHJldHVybjtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgJChlbCkuYXR0cignc3JjJywgcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShmaWxlUGF0aCksIHNyYykpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgJChlbCkudGV4dChgJHtlLm1lc3NhZ2V9XFxuJHtlLnN0YWNrfWApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjb2RlOiAkLmh0bWwoKSxcclxuICAgICAgbWltZVR5cGU6ICd0ZXh0L2h0bWwnXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZ2V0Q29tcGlsZXJWZXJzaW9uKCkge1xyXG4gICAgbGV0IHRoaXNWZXJzaW9uID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcclxuICAgIGxldCBjb21waWxlcnMgPSB0aGlzLmFsbENvbXBpbGVycyB8fCBbXTtcclxuICAgIGxldCBvdGhlclZlcnNpb25zID0gY29tcGlsZXJzLm1hcCgoeCkgPT4geC5nZXRDb21waWxlclZlcnNpb24pLmpvaW4oKTtcclxuXHJcbiAgICByZXR1cm4gYCR7dGhpc1ZlcnNpb259LCR7b3RoZXJWZXJzaW9uc31gO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGZpeHVwUmVsYXRpdmVVcmwodXJsKSB7XHJcbiAgICBpZiAoIXVybC5tYXRjaCgvXlxcL1xcLy8pKSByZXR1cm4gdXJsO1xyXG4gICAgcmV0dXJuIGBodHRwczoke3VybH1gO1xyXG4gIH1cclxufVxyXG4iXX0=