'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _compilerBase = require('../compiler-base');

var _path = require('path');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const mimeTypes = ['text/stylus'];

let stylusjs = null;
let nib = null;

function each(obj, sel) {
  for (let k in obj) {
    sel(obj[k], k);
  }
}

/**
 * @access private
 */
class StylusCompiler extends _compilerBase.CompilerBase {
  constructor() {
    super();

    this.compilerOptions = {
      sourcemap: 'inline',
      import: ['nib']
    };
  }

  static getInputMimeTypes() {
    return mimeTypes;
  }

  shouldCompileFile(fileName, compilerContext) {
    return _asyncToGenerator(function* () {
      return true;
    })();
  }

  determineDependentFiles(sourceCode, filePath, compilerContext) {
    return _asyncToGenerator(function* () {
      return [];
    })();
  }

  compile(sourceCode, filePath, compilerContext) {
    var _this = this;

    return _asyncToGenerator(function* () {
      nib = nib || require('nib');
      stylusjs = stylusjs || require('stylus');
      let opts = _this.makeOpts(filePath);

      let code = yield new Promise(function (res, rej) {
        let styl = stylusjs(sourceCode, opts);

        _this.applyOpts(opts, styl);

        styl.render(function (err, css) {
          if (err) {
            rej(err);
          } else {
            res(css);
          }
        });
      });

      return {
        code, mimeType: 'text/css'
      };
    })();
  }

  makeOpts(filePath) {
    let opts = Object.assign({}, this.compilerOptions, {
      filename: (0, _path.basename)(filePath)
    });

    if (opts.import && !Array.isArray(opts.import)) {
      opts.import = [opts.import];
    }

    if (opts.import && opts.import.indexOf('nib') >= 0) {
      opts.use = opts.use || [];

      if (!Array.isArray(opts.use)) {
        opts.use = [opts.use];
      }

      opts.use.push(nib());
    }

    return opts;
  }

  applyOpts(opts, stylus) {
    each(opts, (val, key) => {
      switch (key) {
        case 'set':
        case 'define':
          each(val, (v, k) => stylus[key](k, v));
          break;
        case 'include':
        case 'import':
        case 'use':
          each(val, v => stylus[key](v));
          break;
      }
    });
  }

  shouldCompileFileSync(fileName, compilerContext) {
    return true;
  }

  determineDependentFilesSync(sourceCode, filePath, compilerContext) {
    return [];
  }

  compileSync(sourceCode, filePath, compilerContext) {
    nib = nib || require('nib');
    stylusjs = stylusjs || require('stylus');

    let opts = this.makeOpts(filePath),
        styl = stylusjs(sourceCode, opts);

    this.applyOpts(opts, styl);

    return {
      code: styl.render(),
      mimeType: 'text/css'
    };
  }

  getCompilerVersion() {
    return require('stylus/package.json').version;
  }
}
exports.default = StylusCompiler;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jc3Mvc3R5bHVzLmpzIl0sIm5hbWVzIjpbIm1pbWVUeXBlcyIsInN0eWx1c2pzIiwibmliIiwiZWFjaCIsIm9iaiIsInNlbCIsImsiLCJTdHlsdXNDb21waWxlciIsImNvbnN0cnVjdG9yIiwiY29tcGlsZXJPcHRpb25zIiwic291cmNlbWFwIiwiaW1wb3J0IiwiZ2V0SW5wdXRNaW1lVHlwZXMiLCJzaG91bGRDb21waWxlRmlsZSIsImZpbGVOYW1lIiwiY29tcGlsZXJDb250ZXh0IiwiZGV0ZXJtaW5lRGVwZW5kZW50RmlsZXMiLCJzb3VyY2VDb2RlIiwiZmlsZVBhdGgiLCJjb21waWxlIiwicmVxdWlyZSIsIm9wdHMiLCJtYWtlT3B0cyIsImNvZGUiLCJQcm9taXNlIiwicmVzIiwicmVqIiwic3R5bCIsImFwcGx5T3B0cyIsInJlbmRlciIsImVyciIsImNzcyIsIm1pbWVUeXBlIiwiT2JqZWN0IiwiYXNzaWduIiwiZmlsZW5hbWUiLCJBcnJheSIsImlzQXJyYXkiLCJpbmRleE9mIiwidXNlIiwicHVzaCIsInN0eWx1cyIsInZhbCIsImtleSIsInYiLCJzaG91bGRDb21waWxlRmlsZVN5bmMiLCJkZXRlcm1pbmVEZXBlbmRlbnRGaWxlc1N5bmMiLCJjb21waWxlU3luYyIsImdldENvbXBpbGVyVmVyc2lvbiIsInZlcnNpb24iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUNBOzs7O0FBRUEsTUFBTUEsWUFBWSxDQUFDLGFBQUQsQ0FBbEI7O0FBRUEsSUFBSUMsV0FBVyxJQUFmO0FBQ0EsSUFBSUMsTUFBTSxJQUFWOztBQUVBLFNBQVNDLElBQVQsQ0FBY0MsR0FBZCxFQUFtQkMsR0FBbkIsRUFBd0I7QUFDdEIsT0FBSyxJQUFJQyxDQUFULElBQWNGLEdBQWQsRUFBbUI7QUFDakJDLFFBQUlELElBQUlFLENBQUosQ0FBSixFQUFZQSxDQUFaO0FBQ0Q7QUFDRjs7QUFFRDs7O0FBR2UsTUFBTUMsY0FBTixvQ0FBMEM7QUFDdkRDLGdCQUFj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Qyx3QkFBc0IvQixRQUF0QixFQUFnQ0MsZUFBaEMsRUFBaUQ7QUFDL0MsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQrQiw4QkFBNEI3QixVQUE1QixFQUF3Q0MsUUFBeEMsRUFBa0RILGVBQWxELEVBQW1FO0FBQ2pFLFdBQU8sRUFBUDtBQUNEOztBQUVEZ0MsY0FBWTlCLFVBQVosRUFBd0JDLFFBQXhCLEVBQWtDSCxlQUFsQyxFQUFtRDtBQUNqRGIsVUFBTUEsT0FBT2tCLFFBQVEsS0FBUixDQUFiO0FBQ0FuQixlQUFXQSxZQUFZbUIsUUFBUSxRQUFSLENBQXZCOztBQUVBLFFBQUlDLE9BQU8sS0FBS0MsUUFBTCxDQUFjSixRQUFkLENBQVg7QUFBQSxRQUFvQ1MsT0FBTzFCLFNBQVNnQixVQUFULEVBQXFCSSxJQUFyQixDQUEzQzs7QUFFQSxTQUFLTyxTQUFMLENBQWVQLElBQWYsRUFBcUJNLElBQXJCOztBQUVBLFdBQU87QUFDTEosWUFBTUksS0FBS0UsTUFBTCxFQUREO0FBRUxHLGdCQUFVO0FBRkwsS0FBUDtBQUlEOztBQUVEZ0IsdUJBQXFCO0FBQ25CLFdBQU81QixRQUFRLHFCQUFSLEVBQStCNkIsT0FBdEM7QUFDRDtBQTdHc0Q7a0JBQXBDMUMsYyIsImZpbGUiOiJzdHlsdXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBpbGVyQmFzZX0gZnJvbSAnLi4vY29tcGlsZXItYmFzZSc7XHJcbmltcG9ydCB7YmFzZW5hbWV9IGZyb20gJ3BhdGgnO1xyXG5cclxuY29uc3QgbWltZVR5cGVzID0gWyd0ZXh0L3N0eWx1cyddO1xyXG5cclxubGV0IHN0eWx1c2pzID0gbnVsbDtcclxubGV0IG5pYiA9IG51bGw7XHJcblxyXG5mdW5jdGlvbiBlYWNoKG9iaiwgc2VsKSB7XHJcbiAgZm9yIChsZXQgayBpbiBvYmopIHtcclxuICAgIHNlbChvYmpba10sIGspO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBhY2Nlc3MgcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3R5bHVzQ29tcGlsZXIgZXh0ZW5kcyBDb21waWxlckJhc2Uge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLmNvbXBpbGVyT3B0aW9ucyA9IHtcclxuICAgICAgc291cmNlbWFwOiAnaW5saW5lJyxcclxuICAgICAgaW1wb3J0OiBbJ25pYiddXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldElucHV0TWltZVR5cGVzKCkge1xyXG4gICAgcmV0dXJuIG1pbWVUeXBlcztcclxuICB9XHJcblxyXG4gIGFzeW5jIHNob3VsZENvbXBpbGVGaWxlKGZpbGVOYW1lLCBjb21waWxlckNvbnRleHQpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZGV0ZXJtaW5lRGVwZW5kZW50RmlsZXMoc291cmNlQ29kZSwgZmlsZVBhdGgsIGNvbXBpbGVyQ29udGV4dCkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgY29tcGlsZShzb3VyY2VDb2RlLCBmaWxlUGF0aCwgY29tcGlsZXJDb250ZXh0KSB7XHJcbiAgICBuaWIgPSBuaWIgfHwgcmVxdWlyZSgnbmliJyk7XHJcbiAgICBzdHlsdXNqcyA9IHN0eWx1c2pzIHx8IHJlcXVpcmUoJ3N0eWx1cycpO1xyXG4gICAgbGV0IG9wdHMgPSB0aGlzLm1ha2VPcHRzKGZpbGVQYXRoKTtcclxuXHJcbiAgICBsZXQgY29kZSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXMscmVqKSA9PiB7XHJcbiAgICAgIGxldCBzdHlsID0gc3R5bHVzanMoc291cmNlQ29kZSwgb3B0cyk7XHJcblxyXG4gICAgICB0aGlzLmFwcGx5T3B0cyhvcHRzLCBzdHlsKTtcclxuXHJcbiAgICAgIHN0eWwucmVuZGVyKChlcnIsIGNzcykgPT4ge1xyXG4gICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgIHJlaihlcnIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXMoY3NzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY29kZSwgbWltZVR5cGU6ICd0ZXh0L2NzcydcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBtYWtlT3B0cyhmaWxlUGF0aCkge1xyXG4gICAgbGV0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbXBpbGVyT3B0aW9ucywge1xyXG4gICAgICBmaWxlbmFtZTogYmFzZW5hbWUoZmlsZVBhdGgpXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAob3B0cy5pbXBvcnQgJiYgIUFycmF5LmlzQXJyYXkob3B0cy5pbXBvcnQpKSB7XHJcbiAgICAgIG9wdHMuaW1wb3J0ID0gW29wdHMuaW1wb3J0XTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0cy5pbXBvcnQgJiYgb3B0cy5pbXBvcnQuaW5kZXhPZignbmliJykgPj0gMCkge1xyXG4gICAgICBvcHRzLnVzZSA9IG9wdHMudXNlIHx8IFtdO1xyXG5cclxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdHMudXNlKSkge1xyXG4gICAgICAgIG9wdHMudXNlID0gW29wdHMudXNlXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgb3B0cy51c2UucHVzaChuaWIoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9wdHM7XHJcbiAgfVxyXG4gIFxyXG4gIFxyXG4gIGFwcGx5T3B0cyhvcHRzLCBzdHlsdXMpIHtcclxuICAgIGVhY2gob3B0cywgKHZhbCwga2V5KSA9PiB7XHJcbiAgICAgIHN3aXRjaChrZXkpIHtcclxuICAgICAgY2FzZSAnc2V0JzpcclxuICAgICAgY2FzZSAnZGVmaW5lJzpcclxuICAgICAgICBlYWNoKHZhbCwgKHYsIGspID0+IHN0eWx1c1trZXldKGssIHYpKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnaW5jbHVkZSc6XHJcbiAgICAgIGNhc2UgJ2ltcG9ydCc6XHJcbiAgICAgIGNhc2UgJ3VzZSc6XHJcbiAgICAgICAgZWFjaCh2YWwsICh2KSA9PiBzdHlsdXNba2V5XSh2KSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc2hvdWxkQ29tcGlsZUZpbGVTeW5jKGZpbGVOYW1lLCBjb21waWxlckNvbnRleHQpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgZGV0ZXJtaW5lRGVwZW5kZW50RmlsZXNTeW5jKHNvdXJjZUNvZGUsIGZpbGVQYXRoLCBjb21waWxlckNvbnRleHQpIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcblxyXG4gIGNvbXBpbGVTeW5jKHNvdXJjZUNvZGUsIGZpbGVQYXRoLCBjb21waWxlckNvbnRleHQpIHtcclxuICAgIG5pYiA9IG5pYiB8fCByZXF1aXJlKCduaWInKTtcclxuICAgIHN0eWx1c2pzID0gc3R5bHVzanMgfHwgcmVxdWlyZSgnc3R5bHVzJyk7XHJcblxyXG4gICAgbGV0IG9wdHMgPSB0aGlzLm1ha2VPcHRzKGZpbGVQYXRoKSwgc3R5bCA9IHN0eWx1c2pzKHNvdXJjZUNvZGUsIG9wdHMpO1xyXG5cclxuICAgIHRoaXMuYXBwbHlPcHRzKG9wdHMsIHN0eWwpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNvZGU6IHN0eWwucmVuZGVyKCksXHJcbiAgICAgIG1pbWVUeXBlOiAndGV4dC9jc3MnXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZ2V0Q29tcGlsZXJWZXJzaW9uKCkge1xyXG4gICAgcmV0dXJuIHJlcXVpcmUoJ3N0eWx1cy9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xyXG4gIH1cclxufVxyXG4iXX0=