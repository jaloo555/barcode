"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.executorHolder = exports.DigestTransform = exports.HttpError = exports.HttpExecutorHolder = undefined;
exports.githubRequest = githubRequest;
exports.request = request;
exports.checkSha2 = checkSha2;
exports.calculateDownloadProgress = calculateDownloadProgress;

var _crypto;

function _load_crypto() {
    return _crypto = require("crypto");
}

var _stream;

function _load_stream() {
    return _stream = require("stream");
}

class HttpExecutorHolder {
    get httpExecutor() {
        if (this._httpExecutor == null) {
            this._httpExecutor = new (require(global.__test_app == null ? "./nodeHttpExecutor" : "out/util/nodeHttpExecutor").NodeHttpExecutor)();
        }
        return this._httpExecutor;
    }
    set httpExecutor(value) {
        this._httpExecutor = value;
    }
}
exports.HttpExecutorHolder = HttpExecutorHolder;
class HttpError extends Error {
    constructor(response) {
        let description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        super(response.statusCode + " " + response.statusMessage + (description == null ? "" : "\n" + JSON.stringify(description, null, "  ")) + "\nHeaders: " + JSON.stringify(response.headers, null, "  "));
        this.response = response;
        this.description = description;
    }
}
exports.HttpError = HttpError;
class DigestTransform extends (_stream || _load_stream()).Transform {
    constructor(expected) {
        super();
        this.expected = expected;
        this.digester = (0, (_crypto || _load_crypto()).createHash)("sha256");
    }
    _transform(chunk, encoding, callback) {
        this.digester.update(chunk);
        callback(null, chunk);
    }
    _flush(callback) {
        const hash = this.digester.digest("hex");
        callback(hash === this.expected ? null : new Error(`SHA2 checksum mismatch, expected ${ this.expected }, got ${ hash }`));
    }
}
exports.DigestTransform = DigestTransform;
const executorHolder = exports.executorHolder = new HttpExecutorHolder();
function githubRequest(path, token) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let method = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "GET";

    return request({ hostname: "api.github.com", path: path }, token, data, method);
}
function request(url) {
    let token = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let method = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "GET";

    return executorHolder.httpExecutor.request(url, token, data, method);
}
function checkSha2(sha2Header, sha2, callback) {
    if (sha2Header != null && sha2 != null) {
        // todo why bintray doesn't send this header always
        if (sha2Header == null) {
            callback(new Error("checksum is required, but server response doesn't contain X-Checksum-Sha2 header"));
            return false;
        } else if (sha2Header !== sha2) {
            callback(new Error(`checksum mismatch: expected ${ sha2 } but got ${ sha2Header } (X-Checksum-Sha2 header)`));
            return false;
        }
    }
    return true;
}
function calculateDownloadProgress(total, start, transferred, chunk, callback) {
    transferred += chunk.length;
    callback({
        total: total,
        transferred: transferred,
        percent: (transferred / total * 100).toFixed(2),
        bytesPerSecond: Math.round(transferred / ((Date.now() - start) / 1000))
    });
    return transferred;
}
//# sourceMappingURL=httpExecutor.js.map